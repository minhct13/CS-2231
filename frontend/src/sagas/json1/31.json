{"topic": "<ul class=\"tags\">\n<a class=\"tag\" href=\"/tags#Neural-nets\">Neural-nets</a>\n<a class=\"tag\" href=\"/tags#Supervised-learning\">Supervised-learning</a>\n<a class=\"tag\" href=\"/tags#Regression\">Regression</a>\n<a class=\"tag\" href=\"/tags#Multi-class\">Multi-class</a>\n<a class=\"tag\" href=\"/tags#MNIST\">MNIST</a>\n</ul>", "title": "<h1 class=\"post-title\" itemprop=\"name\">Bài 13: Softmax Regression</h1>", "introduction": {"title": "<h2 id=\"1-giới-thiệu\">1. Giới thiệu</h2>", "content": "<p>Tôi xin phép được bắt đầu từ mô hình <a href=\"/2017/02/11/binaryclassifiers/#one-vs-rest-hay-one-hot-coding\"><strong>one-vs-rest</strong></a> được trình bày trong bài trước. Output layer (màu đỏ nhạt) có thể phân tách thành hai <em>sublayer</em> như hình dưới đây:</p><div class=\"imgcap\">\n<img align=\"center\" src=\"\\assets\\13_softmax\\onevsrest.png\" width=\"600\"/>\n<div class=\"thecap\">Hình 1: Multi-class classification với Logistic Regression và one-vs-rest.</div>\n</div><p>Dữ liệu \\(\\mathbf{x}\\) có số chiều là \\((d +1)\\) vì có phần tử 1 được thêm vào phía trước, thể hiện hệ số tự do trong hàm tuyến tính. Hệ số tự do \\(w_{0j}\\) còn được gọi là bias.</p><p>Giả sử số classes là \\(C\\). Với one-vs-rest, chúng ta cần xây dựng \\(C\\) Logistic Regression khác nhau. Các <em>đầu ra dự đoán</em> được tính theo hàm sigmoid:\n\\[\na_i = \\text{sigmoid}(z_i) = \\text{sigmoid}(\\mathbf{w}_i^T\\mathbf{x})\n\\]\nTrong kỹ thuật này, các phần tử \\(a_i, i = 1, 2, \\dots, C\\) được suy ra trực tiếp chỉ với \\(z_i\\). Vì vậy, không có mối quan hệ chặt chẽ nào giữa các \\(a_i\\), tức tổng của chúng có thể nhỏ hơn hoặc lớn hơn 1. Nếu ta có thể khai thác được mỗi quan hệ giữa các \\(z_i\\) thì kết quả của bài toán classification có thể tốt hơn.</p><p>Chú ý rằng các mô hình Linear Regression, PLA, Logistic Regression chỉ có 1 node ở output layer. Trong các trường hợp đó, tham số mô hình chỉ là 1 vector \\(\\mathbf{w}\\). Trong trường hợp output layer có nhiều hơn 1 node, tham số mô hình sẽ là tập hợp \ntham số \\(\\mathbf{w}_i\\) ứng với từng node. Lúc này, ta có <em>ma trận trọng số</em> \\(\\mathbf{W} = [\\mathbf{w}_1, \\mathbf{w}_2, \\dots, \\mathbf{w}_C]\\).</p><p><a name=\"-softmax-function\"></a></p>"}, "formulas": {"title": "<h2 id=\"2-softmax-function\">2. Softmax function</h2>", "content": "<p><a name=\"-cong-thuc-cua-softmax-function\"></a></p><h3 id=\"21-công-thức-của-softmax-function\">2.1. Công thức của Softmax function</h3><p>Chúng ta cần một mô hình xác suất sao cho với mỗi input \\(\\mathbf{x}\\), \\(a_i\\) thể hiện xác suất để input đó rơi vào class \\(i\\). Vậy điều kiện cần là các \\(a_i\\) phải dương và tổng của chúng bằng 1. Để có thể thỏa mãn điều kiện này, chúng ta cần <em>nhìn vào</em> mọi giá trị \\(z_i\\) và dựa trên quan hệ giữa các \\(z_i\\) này để tính toán giá trị của \\(a_i\\). Ngoài các điều kiện \\(a_i\\) lớn hơn 0 và có tổng bằng 1, chúng ta sẽ thêm một điều kiện cũng rất tự nhiên nữa, đó là: giá trị \\(z_i = \\mathbf{w}_i^T\\mathbf{x}\\) càng lớn thì xác suất dữ liệu rơi vào class \\(i\\) càng cao. Điều kiện cuối này chỉ ra rằng chúng ta cần một hàm đồng biến ở đây.</p><p>Chú ý rằng \\(z_i \\) có thể nhận giá trị cả âm và dương. Một hàm số <em>mượt</em> đơn giản có thể chắc chắn biến  \\(z_i \\) thành một giá trị dương, và hơn nữa, đồng biến, là hàm \\(\\exp(z_i) = e^{z_i}\\). Điều kiện <em>mượt</em> để thuận lợi hơn trong việc tính đạo hàm sau này. Điều kiện cuối cùng, tổng các \\(a_i\\) bằng 1 có thể được đảm bảo nếu:</p><p>\\[\na_i = \\frac{\\exp(z_i)}{\\sum_{j=1}^C \\exp(z_j)}, ~~ \\forall i = 1, 2, \\dots, C\n\\]</p><p>Hàm số này, tính tất cả các \\(a_i\\) dựa vào tất cả các \\(z_i\\), thõa mãn tất cả các điều kiện đã xét: dương, tổng bằng 1, giữ được <em>thứ tự</em> của \\(z_i\\). Hàm số này được gọi là <em>softmax function</em>. Chú ý rằng với cách định nghĩa này, không có xác suất \\(a_i\\) nào tuyệt đối bằng 0 hoặc tuyệt đối bằng 1, mặc dù chúng có thể rất gần 0 hoặc 1 khi \\(z_i\\) rất nhỏ hoặc rất lớn khi so sánh với các \\(z_j, j \\neq i\\).</p><p>Lúc này, ta có thể giả sử rằng:</p><p>\\[\nP(y_k = i | \\mathbf{x}_k; \\mathbf{W}) = a_i\n\\]</p><p>Trong đó, \\(P(y = i | \\mathbf{x}; \\mathbf{W})\\) được hiểu là xác suất để một điểm dữ liệu \\(\\mathbf{x}\\) rơi vào class thứ \\(i\\) nếu biết tham số mô hình (ma trận trọng số) là \\(\\mathbf{W}\\).</p><p>Hình vẽ dưới đây thể hiện mạng Softmax Regression dưới dạng neural network:</p><div class=\"imgcap\">\n<img align=\"center\" src=\"\\assets\\13_softmax\\softmax_nn.png\" width=\"800\"/>\n<div class=\"thecap\">Hình 2: Mô hình Softmax Regression dưới dạng Neural network.</div>\n</div><p>Ở phần bên phải, hàm tuyến tính \\(\\Sigma\\) và hàm softmax (activation function) được tách riêng ra để phục vụ cho mục đích minh họa. Dạng <em>short form</em> ở bên phải là dạng hay được sử dụng trong các Neural Networks, lớp \\(\\mathbf{a}\\) được ngầm hiểu là bao gồm cả lớp \\(\\mathbf{z}\\).</p><p><a name=\"-softmax-function-trong-python\"></a></p><h3 id=\"22-softmax-function-trong-python\">2.2. Softmax function trong Python</h3><p>Dưới đây là một đoạn code viết hàm softmax. Đầu vào là một ma trận với mỗi cột là một vector \\(\\mathbf{z}\\), đầu ra cũng là một ma trận mà mỗi cột có giá trị là \\(\\mathbf{a} = \\text{softmax}(\\mathbf{z})\\). Các giá trị của \\(\\mathbf{z}\\) còn được gọi là <strong>scores</strong>.</p><div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kn\">import</span> <span class=\"nn\">numpy</span> <span class=\"k\">as</span> <span class=\"n\">np</span> \n\n<span class=\"k\">def</span> <span class=\"nf\">softmax</span><span class=\"p\">(</span><span class=\"n\">Z</span><span class=\"p\">):</span>\n    <span class=\"s\">\"\"\"\n    Compute softmax values for each sets of scores in V.\n    each column of V is a set of score.    \n    \"\"\"</span>\n    <span class=\"n\">e_Z</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"p\">.</span><span class=\"n\">exp</span><span class=\"p\">(</span><span class=\"n\">Z</span><span class=\"p\">)</span>\n    <span class=\"n\">A</span> <span class=\"o\">=</span> <span class=\"n\">e_Z</span> <span class=\"o\">/</span> <span class=\"n\">e_Z</span><span class=\"p\">.</span><span class=\"nb\">sum</span><span class=\"p\">(</span><span class=\"n\">axis</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">)</span>\n    <span class=\"k\">return</span> <span class=\"n\">A</span>\n</code></pre></div></div><p><a name=\"-mot-vai-vi-du\"></a></p><h3 id=\"23-một-vài-ví-dụ\">2.3. Một vài ví dụ</h3><p>Hình 3 dưới đây là một vài ví dụ về mối quan hệ giữa đầu vào và đầu ra của hàm softmax. Hàng trên màu xanh nhạt thể hiện các scores \\(z_i\\) với giả sử rằng số classes là 3. Hàng dưới màu đỏ nhạt thể hiện các giá trị đầu ra \\(a_i\\) của hàm softmax.</p><div class=\"imgcap\">\n<img align=\"center\" src=\"\\assets\\13_softmax\\softmax_ex.png\" width=\"600\"/>\n<div class=\"thecap\">Hình 3: Một số ví dụ về đầu vào và đầu ra của hàm softmax.</div>\n</div><p>Có một vài quan sát như sau:</p><ul>\n<li>\n<p>Cột 1: Nếu các \\(z_i\\) bằng nhau, thì các \\(a_i\\) cũng bằng nhau và bằng 1/3.</p>\n</li>\n<li>\n<p>Cột 2: Nếu giá trị lớn nhất trong các \\(z_i\\) là \\(z_1\\) vẫn bằng 2, nhưng các giá trị khác thay đổi, thì mặc dù xác suất tương ứng \\(a_1\\) vẫn là lớn nhất, nhưng nó đã thay đổi lên hơn 0.5. Đây chính là một lý do mà tên của hàm này có từ <em>soft</em>. (<em>max</em> vì phẩn từ lớn nhất vẫn là phần tử lớn nhất).</p>\n</li>\n<li>\n<p>Cột 3: Khi các giá trị \\(z_i\\) là âm thì các giá trị \\(a_i\\) vẫn là dương và thứ tự vẫn được đảm bảo.</p>\n</li>\n<li>\n<p>Cột 4: Nếu \\(z_1 = z_2\\), thì \\(a_1 = a_2\\).</p>\n</li>\n</ul><p>Bạn đọc có thể thử với các giá trị khác trực tiếp trên trình duyệt trong <a href=\"http://neuralnetworksanddeeplearning.com/chap3.html\">link này</a>, kéo xuống phần Softmax.</p><p><a name=\"-phien-ban-on-dinh-hon-cua-softmax-function\"></a></p><h3 id=\"24-phiên-bản-ổn-định-hơn-của-softmax-function\">2.4. Phiên bản ổn định hơn của softmax function</h3><p>Khi một trong các \\(z_i\\) quá lớn, việc tính toán \\(\\exp(z_i)\\) có thể gây ra hiện tượng tràn số (overflow), ảnh hưởng lớn tới kết quả của hàm softmax. Có một cách khắc phục hiện tượng này bằng cách dựa trên quan sát sau:</p><p>\\[\n\\begin{eqnarray}\n\\frac{\\exp(z_i)}{\\sum_{j=1}^C \\exp(z_j)} &amp;=&amp; \\frac{\\exp(-c)\\exp(z_i)}{\\exp(-c)\\sum_{j=1}^C \\exp(z_j)}\\newline\n&amp;=&amp; \\frac{\\exp(z_i-c)}{\\sum_{j=1}^C \\exp(z_j-c)}\n\\end{eqnarray}\n\\]\nvới \\(c\\) là một hằng số bất kỳ.</p><p>Vậy một phương pháp đơn giản giúp khắc phục hiện tượng overflow là trừ tất cả các \\(z_i\\) đi một giá trị đủ lớn. Trong thực nghiệm, giá trị đủ lớn này thường được chọn là \\(c = \\max_i z_i\\). Vậy chúng ta có thể sửa đoạn code cho hàm <code class=\"language-plaintext highlighter-rouge\">softmax</code> phía trên bằng cách trừ mỗi cột của ma trận đầu vào <code class=\"language-plaintext highlighter-rouge\">Z</code> đi giá trị lớn nhất trong cột đó. Ta có phiên bản ổn định hơn là <code class=\"language-plaintext highlighter-rouge\">softmax_stable</code>:</p><div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">def</span> <span class=\"nf\">softmax_stable</span><span class=\"p\">(</span><span class=\"n\">Z</span><span class=\"p\">):</span>\n    <span class=\"s\">\"\"\"\n    Compute softmax values for each sets of scores in Z.\n    each column of Z is a set of score.    \n    \"\"\"</span>\n    <span class=\"n\">e_Z</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"p\">.</span><span class=\"n\">exp</span><span class=\"p\">(</span><span class=\"n\">Z</span> <span class=\"o\">-</span> <span class=\"n\">np</span><span class=\"p\">.</span><span class=\"nb\">max</span><span class=\"p\">(</span><span class=\"n\">Z</span><span class=\"p\">,</span> <span class=\"n\">axis</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">keepdims</span> <span class=\"o\">=</span> <span class=\"bp\">True</span><span class=\"p\">))</span>\n    <span class=\"n\">A</span> <span class=\"o\">=</span> <span class=\"n\">e_Z</span> <span class=\"o\">/</span> <span class=\"n\">e_Z</span><span class=\"p\">.</span><span class=\"nb\">sum</span><span class=\"p\">(</span><span class=\"n\">axis</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">)</span>\n    <span class=\"k\">return</span> <span class=\"n\">A</span>\n</code></pre></div></div><p>trong đó <code class=\"language-plaintext highlighter-rouge\">axis = 0</code> nghĩa là lấy <code class=\"language-plaintext highlighter-rouge\">max</code> theo cột (<code class=\"language-plaintext highlighter-rouge\">axis = 1</code> sẽ lấy max theo hàng), <code class=\"language-plaintext highlighter-rouge\">keepdims = True</code> để đảm bảo phép trừ giữa ma trận <code class=\"language-plaintext highlighter-rouge\">Z</code> và vector  thực hiện được.</p><p><a name=\"-ham-mat-mat-va-phuong-phap-toi-uu\"></a></p>"}, "examples": {"title": "<h2 id=\"3-hàm-mất-mát-và-phương-pháp-tối-ưu\">3. Hàm mất mát và phương pháp tối ưu</h2>", "content": "<p><a name=\"-one-hot-coding\"></a></p><h3 id=\"31-one-hot-coding\">3.1. One hot coding</h3><p>Với cách biểu diễn network như trên, mỗi output sẽ không còn là một giá trị tương ứng với mỗi class nữa mà sẽ là một vector có đúng 1 phần tử bằng 1, các phần tử còn lại bằng 0. Phần tử bằng 1 năm ở vị trí tương ứng với class đó, thể hiện rằng điểm dữ liệu đang xét rơi vào class này với xác suất bằng 1 (<em>sự thật</em> là như thế, không cần dự đoán). Cách <em>mã hóa</em> output này chính là <em>one-hot coding</em> mà tôi đã đề cập trong bài <a href=\"/2017/01/01/kmeans/\">K-means clustering</a> và <a href=\"/2017/02/11/binaryclassifiers/#one-vs-rest-hay-one-hot-coding\">bài trước</a>.</p><p>Khi sử dụng mô hình Softmax Regression, với mỗi đầu vào \\(\\mathbf{x}\\), ta sẽ có <em>đầu ra dự đoán</em> là \\(\\mathbf{a} = \\text{softmax}(\\mathbf{W}^T\\mathbf{x})\\). Trong khi đó, <em>đầu ra thực sự</em> chúng ta có là vector \\(\\mathbf{y}\\) được biểu diễn dưới dạng one-hot coding.</p><p>Hàm mất mát sẽ được xây dựng để tối thiểu sự khác nhau giữa <em>đầu ra dự đoán</em> \\(\\mathbf{a}\\) và <em>đầu ra thực sự</em> \\(\\mathbf{y}\\). Một lựa chọn đầu tiên ta có thể nghĩ tới là:</p><p>\\[\nJ(\\mathbf{W}) = \\sum_{i=1}^N ||\\mathbf{a}_i - \\mathbf{y}_i||_2^2\n\\]\n<strong>Tuy nhiên đây chưa phải là một lựa chọn tốt</strong>. Khi đánh giá sự khác nhau (hay khoảng cách) giữa hai phân bố xác suất (probability distributions), chúng ta có một đại lượng đo đếm khác hiệu quả hơn. Đại lượng đó có tên là <a href=\"https://en.wikipedia.org/wiki/Cross_entropy\"><strong>cross entropy</strong></a>.</p><p><a name=\"-cross-entropy\"></a></p><h3 id=\"32-cross-entropy\">3.2. Cross Entropy</h3><p>Cross entropy giữa hai phân phối \\(\\mathbf{p}\\) và \\(\\mathbf{q}\\) được định nghĩa là:\n\\[\nH(\\mathbf{p}, \\mathbf{q}) = \\mathbf{E_p}[-\\log \\mathbf{q}]\n\\]</p><p>Với \\(\\mathbf{p}\\) và \\(\\mathbf{q}\\) là rời rạc (như \\(\\mathbf{y}\\) và \\(\\mathbf{a}\\) trong bài toán của chúng ta), công thức này được viết dưới dạng:</p><p>\\[\nH(\\mathbf{p}, \\mathbf{q}) =-\\sum_{i=1}^C p_i \\log q_i ~~~ (1)\n\\]</p><p>Để hiểu rõ hơn ưu điểm của hàm cross entropy và hàm bình phương khoảng cách thông thường, chúng ta cùng xem Hình 4 dưới đây. Đây là ví dụ trong trường hợp \\(C = 2\\) và \\(p_1\\) lần lượt nhận các giá trị \\(0.5, 0.1\\) và \\(0.8\\).</p><div>\n<table style=\"border: 0px solid white\" width=\"100%\">\n<tr>\n<td style=\"border: 0px solid white\" width=\"30%\">\n<img src=\"/assets/13_softmax/crossentropy1.png\" style=\"display:block;\" width=\"100%\"/>\n</td>\n<td style=\"border: 0px solid white\" width=\"30%\">\n<img src=\"/assets/13_softmax/crossentropy2.png\" style=\"display:block;\" width=\"100%\"/>\n</td>\n<td style=\"border: 0px solid white\" width=\"30%\">\n<img src=\"/assets/13_softmax/crossentropy3.png\" style=\"display:block;\" width=\"100%\"/>\n</td>\n</tr>\n</table>\n<div class=\"thecap\"> Hình 4: So sánh giữa hàm cross entropy và hàm bình phương khoảng cách. Các điểm màu xanh lục thể hiện các giá trị nhỏ nhất của mỗi hàm. </div>\n</div><p>Có hai nhận xét quan trọng sau đây:</p><ul>\n<li>\n<p>Giá trị nhỏ nhất của cả hai hàm số đạt được khi \\(q = p\\) tại hoành độ của các điểm màu xanh lục.</p>\n</li>\n<li>\n<p>Quan trọng hơn, hàm cross entropy nhận giá trị rất cao (tức loss rất cao) khi \\(q\\) ở xa \\(p\\). Trong khi đó, sự chênh lệch giữa các loss ở gần hay xa nghiệm của hàm bình phương khoảng cách \\((q - p)^2\\) là không đáng kể. Về mặt tối ưu, hàm cross entropy sẽ cho nghiệm <em>gần</em> với \\(p\\) hơn vì những nghiệm ở xa bị <em>trừng phạt</em> rất nặng.</p>\n</li>\n</ul><p>Hai tính chất trên đây khiến cho cross entropy được sử dụng rộng rãi khi tính khoảng cách giữa hai phân phối xác suất.</p><p><strong>Chú ý:</strong> Hàm cross entropy không có tính đối xứng \\(H(\\mathbf{p}, \\mathbf{q}) \\neq H(\\mathbf{q}, \\mathbf{p})\\). Điều này có thể dễ dàng nhận ra ở việc các thành phần của \\(\\mathbf{p}\\) trong công thức \\((1)\\) có thể nhận giá trị bằng 0, trong khi đó các thành phần của \\(\\mathbf{q}\\) phải là dương vì \\(\\log(0)\\) không xác định. Chính vì vậy, khi sử dụng cross entropy trong các bài toán supervised learning, \\(\\mathbf{p}\\) thường là <em>đầu ra thực sự</em> vì đầu ra thực sự chỉ có 1 thành phần bằng 1, còn lại bằng 0 (one-hot), \\(\\mathbf{q}\\) thường là <em>đầu ra dự đoán</em>, khi mà không có xác suất nào tuyệt đối bằng 1 hoặc tuyệt đối bằng 0 cả.</p><p>Trong <a href=\"/2017/01/27/logisticregression/\">Logistic Regression</a>, chúng ta cũng có hai phân phối đơn giản. (i) <em>Đầu ra thực sự</em> của điểm dữ liệu đầu vào \\(\\mathbf{x}_i\\) có phân phối xác suất là \\([y_i; 1 - y_i]\\) với \\(y_i\\) là xác suất để điểm dữ liệu đầu vào rơi vào class thứ nhất (bằng 1 nếu \\(y_i = 1\\), bằng 0 nếu \\(y_i = 0\\)). (ii). <em>Đầu ra dự đoán</em> của điểm dữ liệu đó là \\(a_i = \\text{sigmoid}(\\mathbf{w}^T\\mathbf{x})\\) là xác suất để điểm đó rơi vào class thứ nhất. Xác suất để điểm đó rơi vào class thứ hai có thể được dễ dàng suy ra lf \\(1 - a_i\\). Vì vậy, hàm mất mát trong Logistic Regression:\n\\[\nJ(\\mathbf{w}) = -\\sum_{i=1}^N(y_i \\log {a}_i + (1-y_i) \\log (1 - {a}_i))\n\\]\nchính là một trường hợp đặc biệt của Cross Entropy. (\\(N\\) được dùng để thể hiện số điểm dữ liệu trong tập training).</p><p>Với Softmax Regression, trong trường hợp có \\(C\\) classes, <em>loss</em> giữa đầu ra dự đoán và đầu ra thực sự của một điểm dữ liệu \\(\\mathbf{x}_i\\) được tính bằng:\n\\[\nJ(\\mathbf{W};\\mathbf{x}_i, \\mathbf{y}_i) = -\\sum_{j=1}^C y_{ji}\\log(a_{ji})\n\\]\nVới \\(y_{ji}\\) và \\( a_{ji}\\) lần lượt là là phần tử thứ \\(j\\) của vector (xác suất) \\(\\mathbf{y}_i\\) và \\(\\mathbf{a}_i\\). Nhắc lại rằng đầu ra \\(\\mathbf{a}_i\\) phụ thuộc vào đầu vào \\(\\mathbf{x}_i\\) và ma trận trọng số \\(\\mathbf{W}\\).</p><p><a name=\"-ham-mat-mat-cho-softmax-regression\"></a></p><h3 id=\"33-hàm-mất-mát-cho-softmax-regression\">3.3. Hàm mất mát cho Softmax Regression</h3><p>Kết hợp tất cả các cặp dữ liệu \\(\\mathbf{x}_i, \\mathbf{y}_i, i = 1, 2, \\dots, N\\), chúng ta sẽ có hàm mất mát cho Softmax Regression như sau:</p><p>\\[\n\\begin{eqnarray}\nJ(\\mathbf{W}; \\mathbf{X}, \\mathbf{Y}) = -\\sum_{i = 1}^N \\sum_{j = 1}^C y_{ji}\\log(a_{ji}) \\newline\n= -\\sum_{i = 1}^N \\sum_{j = 1}^C y_{ji}\\log\\left(\\frac{\\exp(\\mathbf{w}_j^T\\mathbf{x}_i)}{\\sum_{k=1}^C \\exp(\\mathbf{w}_k^T\\mathbf{x}_i)}\\right)\n\\end{eqnarray}\n\\]</p><p>Với ma trận trọng số \\(\\mathbf{W}\\) là biến cần tối ưu. Hàm mất mát này trông <em>có vẻ đáng sợ</em>, nhưng đừng sợ, đọc tiếp các bạn sẽ thấy đạo hàm của nó rất đẹp (<em>và đáng yêu</em>).</p><p><a name=\"-toi-uu-ham-mat-mat\"></a></p><h3 id=\"34-tối-ưu-hàm-mất-mát\">3.4. Tối ưu hàm mất mát</h3><p>Một lần nữa, chúng ta lại sử dụng <a href=\"/2017/01/16/gradientdescent2/#-stochastic-gradient-descent\">Stochastic Gradient Descent (SGD)</a> ở đây.</p><p>Với chỉ một cặp dữ liệu \\((\\mathbf{x}_i, \\mathbf{y}_i)\\), ta có: \n\\[\nJ_i(\\mathbf{W}) \\triangleq J(\\mathbf{W}; \\mathbf{x}_i, \\mathbf{y}_i) = \n\\]\n\\[\n\\begin{eqnarray}\n&amp;=&amp; -\\sum_{j = 1}^C y_{ji}\\log\\left(\\frac{\\exp(\\mathbf{w}_j^T\\mathbf{x}_i)}{\\sum_{k=1}^C \\exp(\\mathbf{w}_k^T\\mathbf{x}_i)}\\right) \\newline\n&amp;=&amp; -\\sum_{j=1}^C\\left(y_{ji} \\mathbf{w}_j^T\\mathbf{x}_i - y_{ji}\\log\\left(\\sum_{k=1}^C \\exp(\\mathbf{w}_k^T\\mathbf{x}_i)\\right)\\right) \\newline\n&amp;=&amp; -\\sum_{j=1}^C y_{ji} \\mathbf{w}_j^T\\mathbf{x}_i + \\log\\left(\\sum_{k=1}^C \\exp(\\mathbf{w}_k^T\\mathbf{x}_i)\\right) ~~ (3)\n\\end{eqnarray}\n\\]</p><p>trong biến đổi ở dòng cuối cùng, tôi đã sử dụng quan sát: \\(\\sum_{j=1}^C y_{ji} = 1\\) vì nó là tổng các xác suất.</p><p>Tiếp theo ta sử dụng công thức: \n\\[\n\\frac{\\partial J_i(\\mathbf{W})}{\\partial \\mathbf{W}} = \\left[\\frac{\\partial J_i(\\mathbf{W})}{\\partial \\mathbf{w}_1}, \\frac{\\partial J_i(\\mathbf{W})}{\\partial \\mathbf{w}_2}, \\dots, \\frac{\\partial J_i(\\mathbf{W})}{\\partial \\mathbf{w}_C}    \\right]~~(4)\n\\]</p><p>Trong đó, gradient theo từng cột có thể tính được dựa theo \\((3)\\):</p><p>\\[\n\\begin{eqnarray}\n\\frac{\\partial J_i(\\mathbf{W})}{\\partial \\mathbf{w}_j} &amp;=&amp; -y_{ji}\\mathbf{x}_i + \n\\frac{\\exp(\\mathbf{w}_j^T\\mathbf{x}_i)}{\\sum_{k = 1}^C \\exp(\\mathbf{w}_k^T\\mathbf{x}_i)}\\mathbf{x}_i \\newline\n&amp;=&amp; -y_{ji}\\mathbf{x}_i + a_{ji} \\mathbf{x}_i = \\mathbf{x}_i (a_{ji} - y_{ji}) \\newline\n&amp;=&amp; e_{ji}\\mathbf{x}_{i} ~(\\text{where}~ e_{ji} = a_{ji} - y_{ji}) ~~(5)\n\\end{eqnarray}\n\\]</p><p>Giá trị \\(e_{ji} = a_{ji} - y_{ji} \\) có thể được coi là <em>sai số dự đoán</em>.</p><p>Đến đây ta đã được biểu thức rất đẹp rồi. Kết hợp \\((4)\\) và \\((5)\\) ta có: \n\\[\n\\frac{\\partial J_i(\\mathbf{W})}{\\partial \\mathbf{W}} = \\mathbf{x}_i [e_{1i}, e_{2i}, \\dots, e_{Ci}] = \\mathbf{x}_i\\mathbf{e}_i^T\n\\]\n<a name=\"vi-du-va-luu-y-khi-lap-trinh-voi-python\"></a></p><p>Từ đây ta cũng có thể suy ra rằng:\n\\[\n\\frac{\\partial J(\\mathbf{W})}{\\partial \\mathbf{W}} = \\sum_{i=1}^N \\mathbf{x}_i\\mathbf{e}_i^T = \\mathbf{X}\\mathbf{E}^T\n\\]\nvới \\(\\mathbf{E} = \\mathbf{A - Y}\\). Công thức tính gradient đơn giản thế này giúp cho cả <a href=\"/2017/01/16/gradientdescent2/#-bien-the-cua-gradient-descent\">Batch Gradient Descent, Stochastic Gradient Descent (SGD), và Mini-batch Gradient Descent</a> đều có thể dễ dàng được áp dụng.</p><p>Giả sử rằng chúng ta sử dụng SGD, công thức cập nhật cho ma trận trọng số \\(\\mathbf{W}\\) sẽ là: \n\\[\n\\mathbf{W} = \\mathbf{W} +\\eta \\mathbf{x}_{i}(\\mathbf{y}_i - \\mathbf{a}_i)^T\n\\]</p><p>Bạn có thấy công thức này giống với <a href=\"/2017/01/27/logisticregression/#cong-thuc-cap-nhat-cho-logistic-sigmoid-regression\">công thức cập nhật của Logistic Regression</a> không!</p><p>Thực ra:</p><p><a name=\"-logistic-regression-la-mot-truong-hop-dat-biet-cua-softmax-regression\"></a></p><h3 id=\"35-logistic-regression-là-một-trường-hợp-đặt-biệt-của-softmax-regression\">3.5. Logistic Regression là một trường hợp đặt biệt của Softmax Regression</h3><p>Khi \\(C = 2\\), Softmax Regression và Logistic Regression là giống nhau. Thật vậy, đầu ra dự đoán của Softmax Regression với \\(C= 2\\) có thể được viết dưới dạng: \n\\[\n\\begin{eqnarray}\na_1 &amp;=&amp; \\frac{\\exp(\\mathbf{w}_1^T\\mathbf{x})} {\\exp(\\mathbf{w}_1^T\\mathbf{x}) + \\exp(\\mathbf{w}_2^T\\mathbf{x})} \\newline\n&amp;=&amp; \\frac{1}{1 + \\exp((\\mathbf{w}_2 - \\mathbf{w}_1)^T\\mathbf{x})}\n\\end{eqnarray}\n\\]</p><p>Đây chính là <a href=\"/2017/01/27/logisticregression/#sigmoid-function\">sigmoid function</a>, là đầu ra dự đoán theo Logistic Regression. Khi \\(C = 2\\), bạn đọc cũng có thể thấy rằng hàm mất mát của Logistic và Softmax Regression đều là cross entropy. Hơn nữa, mặc dù có 2 outputs, Softmax Regression có thể rút gọn thành 1 output vì tổng 2 outputs luôn luôn bằng 1.</p><p>Softmax Regression còn có các tên gọi khác là Multinomial Logistic Regression, Maximum Entropy Classifier, hay rất nhiều tên khác nữa. Xem thêm <a href=\"https://en.wikipedia.org/wiki/Multinomial_logistic_regression\">Multinomial logistic regression - Wikipedia</a>\n<a name=\"-mot-vai-luu-y-khi-lap-trinh-voi-python\"></a></p>"}}