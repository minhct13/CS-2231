{"topic": "<ul class=\"tags\">\n<a class=\"tag\" href=\"/tags#Dimensionality-reduction,\">Dimensionality-reduction,</a>\n<a class=\"tag\" href=\"/tags#Matrix-decomposition\">Matrix-decomposition</a>\n</ul>", "title": "<h1 class=\"post-title\" itemprop=\"name\">Bài 26: Singular Value Decomposition</h1>", "introduction": {"title": "<h2 id=\"1-giới-thiệu\">1. Giới thiệu</h2>", "content": "<p>Hẳn các bạn vẫn nhớ một loại bài toán được làm rất nhiều khi học Đại số tuyến tính: Bài toán chéo hoá ma trận. Bài toán đó nói rằng: Một ma trận vuông \\(\\mathbf{A} \\in \\mathbb{R}^{n\\times n}\\) được gọi là <em>chéo hoá được</em> (diagonalizable) nếu tồn tại ma trận đường chéo \\(\\mathbf{D}\\) và ma trận khả nghịch \\(\\mathbf{P}\\) sao cho:\n\\[\n\\mathbf{A} = \\mathbf{P} \\mathbf{D} \\mathbf{P}^{-1}~~~~(1)\n\\]\nSố lượng phần tử khác 0 của ma trận đường chéo \\(\\mathbf{D}\\) chính là rank của ma trận \\(\\mathbf{A}\\).</p><p>Nhân cả hai vế của \\((1)\\) với \\(\\mathbf{P}\\) ta có:</p><p>\\[\n\\mathbf{AP} = \\mathbf{PD}~~~~(2)\n\\]</p><p>Gọi \\(\\mathbf{p}_i, \\mathbf{d}_i\\) lần lượt là cột thứ \\(i\\) của ma trận \\(\\mathbf{P}\\) và \\(\\mathbf{D}\\). Vì mỗi một cột của vế trái và vế phải của \\((2)\\) phải bằng nhau, ta sẽ có:</p><p>\\[\n\\mathbf{Ap}_i = \\mathbf{Pd}_i = d_{ii}\\mathbf{p}_i ~~~~ (3)\n\\]\nvới \\(d_{ii}\\) là phần tử thứ \\(i\\) của \\(\\mathbf{p}_i\\).</p><p>Dấu bằng thứ hai xảy ra vì \\(\\mathbf{D}\\) là ma trận đường chéo, tức \\(\\mathbf{d}_i\\) chỉ có thành phần \\(d_{ii}\\) là khác 0. Và nếu bạn vẫn nhớ, biểu thức \\((3)\\) chỉ ra rằng mỗi phần tử \\(d_{ii}\\) phải là một <em>trị riêng</em> (eigenvalue) của \\(\\mathbf{A}\\) và mỗi vector cột \\(\\mathbf{p}_i\\) phải là một <em>vector riêng</em> (eigenvector) của \\(\\mathbf{A}\\) ứng với trị riêng \\(d_{ii}\\).</p><p>Cách phân tích một ma trận vuông thành nhân tử như \\((1)\\) còn được gọi là <em>Eigen Decomposition</em>.</p><p>Một điểm quan trọng là cách phân tích như \\((1)\\) chỉ được áp dụng với ma trận vuông và không phải lúc nào cũng tồn tại. Nó chỉ tồn tại nếu ma trận \\(\\mathbf{A}\\) có \\(n\\) vector riêng độc lập tuyến tính, vì nếu không thì không tồn tại ma trận \\(\\mathbf{P}\\) khả nghịch. Thêm nữa, cách phân tích này cũng không phải là duy nhất vì nếu \\(\\mathbf{P}, \\mathbf{D}\\) thoả mãn \\((1)\\) thì \\(k\\mathbf{P}, \\mathbf{D}\\) cũng thoả mãn với \\(k\\) là một số thực khác 0 bất kỳ.</p><p>Việc phân tích một ma trận ra thành tích của nhiều ma trận đặc biệt khác (Matrix Factorization hoặc Matrix Decomposition) mang lại nhiều ích lợi quan trọng mà các bạn sẽ thấy: giảm số chiều dữ liệu, nén dữ liệu, tìm hiểu các đặc tính của dữ liệu, giải các hệ phương trình tuyến tính, clustering, và nhiều ứng dụng khác. <a href=\"/2017/05/31/matrixfactorization/\">Recommendation System cũng là một trong rất nhiều ứng dụng của Matrix Factorization</a>.</p><p>Trong bài viết này, tôi sẽ giới thiệu với các bạn một trong những phương pháp Matrix Factorization rất đẹp của Đại số tuyến tính. Phương pháp đó có tên là Singular Value Decomposition (SVD). Các bạn sẽ thấy, mọi ma trận, không nhất thiết là vuông, đều có thể được phân tích thành tích của ba ma trận đặc biệt.</p><p>Dưới đây, tôi sẽ phát biểu SVD cũng như các tính chất và ứng dụng điển hình của nó.</p><p>Trước hết, chúng ta cần ôn tập lại một chút về Đại số tuyến tính. <strong>Chú ý rằng các ma trận trong bài viết này đều được ngầm giả sử là ma trận thực</strong>.</p><p><a name=\"-mot-chut-ve-dai-so-tuyen-tinh\"></a></p>"}, "formulas": {"title": "<h2 id=\"2-một-chút-về-đại-số-tuyến-tính\">2. Một chút về Đại số tuyến tính</h2>", "content": "<p><a name=\"-tri-rieng-va-vector-rieng\"></a></p><h3 id=\"21-trị-riêng-và-vector-riêng\">2.1. Trị riêng và vector riêng</h3><p>Cho một ma trận vuông \\(\\mathbf{A} \\in \\mathbb{R}^{n\\times n}\\), nếu số vô hướng \\(\\lambda\\) và vector \\(\\mathbf{x} \\neq \\mathbf{0} \\in \\mathbb{R}^n\\) thoả mãn:</p><p>\\[\n\\mathbf{Ax} = \\lambda \\mathbf{x}\n\\]\nthì \\(\\lambda\\) được gọi là một trị riêng của \\(\\mathbf{A}\\) và \\(\\mathbf{x}\\) được gọi là vector riêng tương ứng với trị riêng đó.</p><p>Một vài tính chất:</p><ol>\n<li>\n<p>Nếu \\(\\mathbf{x}\\) là một vector riêng của \\(\\mathbf{A}\\) ứng với \\(\\lambda\\) thì \\(k\\mathbf{x}, k \\neq 0\\) cũng là vector riêng ứng với trị riêng đó.</p>\n</li>\n<li>\n<p>Mọi ma trận vuông bậc \\(n\\) đều có \\(n\\) trị riêng (kể cả lặp) và có thể là các số phức.</p>\n</li>\n<li>\n<p>Với ma trận đối xứng, tất cả các trị riêng đều là các số thực.</p>\n</li>\n<li>\n<p>Với <a href=\"/2017/03/12/convexity/#positive-semidefinite\"><em>ma trận xác định dương</em></a>, tất cả các trị riêng của nó đều là các số thực dương. Với <em>ma trận nửa xác định dương</em>, tất cả các trị riêng của nó đều là các số thực không âm.</p>\n</li>\n</ol><p>Tính chất cuối cùng có thể được suy ra từ định nghĩa của ma trận (nửa) xác định dương. Thật vậy, gọi \\(\\mathbf{u} \\neq \\mathbf{0}\\) là vector riêng ứng với một trị riêng \\(\\lambda\\) của ma trận \\(\\mathbf{A}\\) xác định dương, ta có:\n\\[\n\\mathbf{Au} = \\lambda \\mathbf{u} \\Rightarrow \\mathbf{u}^T\\mathbf{Au} = \\lambda \\mathbf{u}^T\\mathbf{u} = \\lambda ||\\mathbf{u}||_2^2\n\\]</p><p>Vì \\(\\mathbf{A}\\) là nửa xác định dương nên với mọi \\(\\mathbf{u} \\neq \\mathbf{0}\\): \\(\\mathbf{u}^T\\mathbf{Au} \\geq 0\\); \\(\\mathbf{u} \\neq 0\\) nên \\(||\\mathbf{u}||_2^2 &gt; 0\\). Từ đó suy ra \\(\\lambda\\) là một số không âm.</p><p><a name=\"-he-truc-giao-va-truc-chuan\"></a></p><h3 id=\"22-hệ-trực-giao-và-trực-chuẩn\">2.2. Hệ trực giao và trực chuẩn</h3><p>Một hệ cơ sở \\({\\mathbf{u}_1, \\mathbf{u}_2,\\dots, \\mathbf{u}_m \\in \\mathbb{R}^m}\\) được gọi là <em>trực giao</em> (orthogonal) nếu mỗi vector là khác 0 và tích của hai vector khác nhau bất kỳ bằng 0:</p><p>\\[\n\\mathbf{u}_i \\neq \\mathbf{0}; ~~ \\mathbf{u}_i^T \\mathbf{u}_j = 0 ~ \\forall ~1 \\leq i \\neq j \\leq m\n\\]</p><p>Một hệ cơ sở \\({\\mathbf{u}_1, \\mathbf{u}_2,\\dots, \\mathbf{u}_m \\in \\mathbb{R}^m}\\) được gọi là <em>trực chuẩn</em> (orthonormal) nếu nó là một hệ <em>trực giao</em> và độ dài Euclidean (norm 2) của mỗi vector bằng 1:</p><p>\\[\n\\begin{eqnarray}\n\\mathbf{u}_i^T \\mathbf{u}_j = \\left\\{\n\\begin{matrix}\n    1 &amp; \\text{if} &amp;i = j \\newline\n    0 &amp; \\text{otherwise}\n\\end{matrix}\n\\right. ~~~~ (4)\n\\end{eqnarray}\n\\]</p><p>Gọi \\(\\mathbf{U} = [\\mathbf{u}_1, \\mathbf{u}_2,\\dots, \\mathbf{u}_m]\\) với \\({\\mathbf{u}_1, \\mathbf{u}_2,\\dots, \\mathbf{u}_m \\in \\mathbb{R}^m}\\) là <em>trực chuẩn</em>, thế thì từ \\((4)\\) có thể suy ra ngay:</p><p>\\[\n\\mathbf{UU}^T = \\mathbf{U}^T\\mathbf{U} = \\mathbf{I}\n\\]</p><p>trong đó \\(\\mathbf{I}\\) là ma trận đơn vị bậc \\(m\\). Ta gọi \\(\\mathbf{U}\\) là <em>ma trận trực giao</em> (orthogonal matrix). <em>Ma trận loại này không được gọi là ma trận trực chuẩn, không có định nghĩa cho ma trận trực chuẩn.</em></p><p>Một vài tính chất:</p><ol>\n<li>\n<p>\\(\\mathbf{U}^{-1} = \\mathbf{U}^T\\): nghịch đảo của một ma trận trực giao chính là chuyển vị của nó.</p>\n</li>\n<li>\n<p>Nếu \\(\\mathbf{U}\\) là ma trận trực giao thì chuyển vị của nó \\(\\mathbf{U}^T\\) cũng là một ma trận trực giao.</p>\n</li>\n<li>\n<p>Định thức (determinant) của ma trận trực giao bằng \\(1\\) hoặc \\(-1\\). Điều này có thể suy ra từ việc \\(\\det(\\mathbf{U}) = \\det(\\mathbf{U}^T)\\) và \\(\\det(\\mathbf{U}) \\det(\\mathbf{U}^T) = \\det(\\mathbf{I}) = 1\\).</p>\n</li>\n<li>\n<p>Ma trận trực giao thể hiện cho phép xoay (rotate) một vector. Giả sử có hai vector \\(\\mathbf{x,y} \\in \\mathbb{R}^m\\) và ma trận trực giao \\(\\mathbf{U} \\in \\mathbb{R}^{m \\times m}\\). Dùng ma trận này để xoay hai vector trên ta được \\(\\mathbf{Ux}, \\mathbf{Uy}\\). Tích vô hướng của hai vector mới là:\n\\[\n(\\mathbf{Ux})^T (\\mathbf{Uy}) = \\mathbf{x}^T \\mathbf{U}^T \\mathbf{Uy} = \\mathbf{x}^T\\mathbf{y}\n\\]\nnhư vậy <em>phép xoay không làm thay đổi tích vô hướng giữa hai vector</em>.</p>\n</li>\n<li>\n<p>Giả sử \\(\\hat{\\mathbf{U}} \\in \\mathbb{R}^{m \\times r}, r &lt; m\\) là môt ma trận con của ma trận trực giao \\(\\mathbf{U}\\) được tạo bởi \\(r\\) cột của \\(\\mathbf{U}\\), ta sẽ có \\(\\hat{\\mathbf{U}}^T\\hat{\\mathbf{U}} = \\mathbf{I}_{r}\\). Việc này có thể được suy ra từ \\((4)\\).</p>\n</li>\n</ol><p><a name=\"-singular-value-decomposition\"></a></p>"}, "examples": {"title": "<h2 id=\"3-singular-value-decomposition\">3. Singular Value Decomposition</h2>", "content": "<p>Vì trong mục này cần nắm vững chiều của mỗi ma trận nên tôi sẽ thay đổi ký hiệu một chút để chúng ta dễ hình dung. Ta sẽ ký hiệu một ma trận cùng với số chiều của nó, ví dụ \\(\\mathbf{A}_{m \\times n}\\) nghĩa là ma trận \\(\\mathbf{A} \\in \\mathbb{R}^{m \\times n}\\).\n<a name=\"-phat-bieu-svd\"></a></p><h3 id=\"31-phát-biểu-svd\">3.1. Phát biểu SVD</h3><hr>\n<p>Một ma trận \\(\\mathbf{A}_{m \\times n}\\) bất kỳ đều có thể phân tích thành dạng:</p>\n<p>\\[\n\\mathbf{A}_{m \\times n} = \\mathbf{U}_{m \\times m}\\mathbf{\\Sigma}_{m \\times n} (\\mathbf{V}_{n \\times n})^T ~~~~ (5)\n\\]</p>\n<p>Trong đó, \\(\\mathbf{U}, \\mathbf{V}\\) là các <em>ma trận trực giao</em>, \\(\\mathbf{\\Sigma}\\) là ma trận <em>đường chéo không vuông</em> với các phần tử trên đường chéo \\(\\sigma_1 \\geq \\sigma_2 \\geq \\dots \\geq\\sigma_r \\geq 0 = 0 = \\dots = 0\\) và \\(r\\) là rank của ma trận \\(\\mathbf{A}\\). Lưu ý rằng mặc dù \\(\\Sigma\\) không phải ma trận vuông, ta vẫn có thể coi nó là ma trận chéo nếu các thành phần khác không của nó chỉ nằm ở vị trí <em>đường chéo</em>, tức tại các vị trí có chỉ số hàng và chỉ số cột là như nhau.</p>\n<p>Số lượng các phần tử khác 0 trong \\(\\Sigma\\) chính là rank của ma trận \\(\\mathbf{A}\\).</p>\n<hr/>\n<p>Nếu bạn muốn xem chứng minh về sự tồn tại của SVD, bạn có thể <a href=\"http://db.cs.duke.edu/courses/cps111/spring07/notes/12.pdf\">xem tại đây</a>.</p>\n<p>Chú ý rằng cách biểu diễn \\((5)\\) không là duy nhất vì ta chỉ cần đổi dấu của cả \\(\\mathbf{U}\\) và \\(\\mathbf{V}\\) thì \\((5)\\) vẫn thoả mãn. Tuy vậy, người ta vẫn thường dùng ‘the SVD’ thay vì ‘a SVD’.</p>\n<p>Hình 1 mô tả SVD của ma trận \\(\\mathbf{A}_{m \\times n}\\) trong hai trường hợp: \\(m &lt; n\\) và \\(m &gt; n\\). Trường hợp \\(m =n\\) có thể xếp vào một trong hai trường hợp trên.</p>\n<hr/>\n<div class=\"imgcap\">\n<img align=\"center\" src=\"/assets/26_svd/svd.png\" width=\"800\"/>\n</div>\n<div align=\"left\" class=\"thecap\">Hình 1: SVD cho ma trận \\(\\mathbf{A}\\) khi: \\(m &lt; n\\) (hình trên), và \\(m &gt; n\\) (hình dưới). \\(\\Sigma\\) là một ma trận đường chéo với các phần tử trên đó giảm dần và không âm. Màu đỏ càng đậm thể hiện giá trị càng cao. Các ô màu trắng trên ma trận này thể hiện giá trị 0.</div>\n<hr/>\n<p><a name=\"-nguon-goc-ten-goi-singular-value-decomposition\"></a></p>\n<h3 id=\"32-nguồn-gốc-tên-gọi-singular-value-decomposition\">3.2. Nguồn gốc tên gọi Singular Value Decomposition</h3>\n<p>Tạm bỏ qua chiều của mỗi ma trận, từ \\((5)\\) ta có:\n\\[\n\\begin{eqnarray}\n\\mathbf{AA}^T &amp;=&amp; \\mathbf{U}\\mathbf{\\Sigma} \\mathbf{V}^T (\\mathbf{U}\\mathbf{\\Sigma} \\mathbf{V}^T)^T \\newline\n&amp;=&amp; \\mathbf{U}\\mathbf{\\Sigma} \\mathbf{V}^T \\mathbf{V}\\mathbf{\\Sigma}^T\\mathbf{U}^T \\newline\n&amp;=&amp; \\mathbf{U}\\mathbf{\\Sigma}\\mathbf{\\Sigma}^T\\mathbf{U}^T =  \\mathbf{U}\\mathbf{\\Sigma}\\mathbf{\\Sigma}^T\\mathbf{U}^{-1} ~~~~~ (6)\n\\end{eqnarray}\n\\]</p>\n<p>Dấu bằng cuối cùng xảy ra vì \\(\\mathbf{V}^T\\mathbf{V} = \\mathbf{I}\\) do \\(\\mathbf{V}\\) là một ma trận trực giao.</p>\n<p>Quan sát thấy rằng \\(\\Sigma\\Sigma^T\\) là một ma trận đường chéo với các phần tử trên đường chéo là \\(\\sigma_1^2, \\sigma_2^2, \\dots\\). Vậy \\((6)\\) chính là Eigen Decomposition của \\(\\mathbf{A}\\mathbf{A}^T\\). Thêm nữa, \\(\\sigma_1^2, \\sigma_2^2, \\dots\\) chính là các trị riêng của \\(\\mathbf{A}\\mathbf{A}^T\\).</p>\n<p>Ma trận \\(\\mathbf{A}\\mathbf{A}^T\\) luôn là ma trận nửa xác định dương nên các trị riêng của nó là không âm. Các \\(\\sigma_i\\) là căn bậc hai của các trị riêng của \\(\\mathbf{A}\\mathbf{A}^T\\) còn được gọi là <em>singular values</em> của \\(\\mathbf{A}\\). Cái tên Singular Value Decomposition xuất phát từ đây.</p>\n<p>Cũng theo đó, mỗi cột của \\(\\mathbf{U}\\) chính là một vector riêng của \\(\\mathbf{A}\\mathbf{A}^T\\). Ta gọi mỗi cột này là <em>left-singular vectors</em> của \\(\\mathbf{A}\\). Tương tự như thế, \\(\\mathbf{A}^T\\mathbf{A} = \\mathbf{V}\\Sigma^T\\Sigma \\mathbf{V}^T\\) và các cột của \\(\\mathbf{V}\\) còn được gọi là các <em>right-singular vectors</em> của \\(\\mathbf{A}\\).</p>\n<p>Trong Python, để tính SVD của một ma trận, chúng ta sử dụng module <code class=\"language-plaintext highlighter-rouge\">linalg</code> của <code class=\"language-plaintext highlighter-rouge\">numpy</code> như sau:</p>\n<div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kn\">import</span> <span class=\"nn\">numpy</span> <span class=\"k\">as</span> <span class=\"n\">np</span>\n<span class=\"kn\">from</span> <span class=\"nn\">numpy</span> <span class=\"kn\">import</span> <span class=\"n\">linalg</span> <span class=\"k\">as</span> <span class=\"n\">LA</span>\n\n<span class=\"n\">m</span><span class=\"p\">,</span> <span class=\"n\">n</span> <span class=\"o\">=</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">3</span>\n<span class=\"n\">A</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"p\">.</span><span class=\"n\">random</span><span class=\"p\">.</span><span class=\"n\">rand</span><span class=\"p\">(</span><span class=\"n\">m</span><span class=\"p\">,</span> <span class=\"n\">n</span><span class=\"p\">)</span>\n\n<span class=\"n\">U</span><span class=\"p\">,</span> <span class=\"n\">S</span><span class=\"p\">,</span> <span class=\"n\">V</span> <span class=\"o\">=</span> <span class=\"n\">LA</span><span class=\"p\">.</span><span class=\"n\">svd</span><span class=\"p\">(</span><span class=\"n\">A</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># checking if U, V are orthogonal and S is a diagonal matrix with\n# nonnegative decreasing elements\n</span><span class=\"k\">print</span> <span class=\"s\">'Frobenius norm of (UU^T - I) ='</span><span class=\"p\">,</span> \\\n    <span class=\"n\">LA</span><span class=\"p\">.</span><span class=\"n\">norm</span><span class=\"p\">(</span><span class=\"n\">U</span><span class=\"p\">.</span><span class=\"n\">dot</span><span class=\"p\">(</span><span class=\"n\">U</span><span class=\"p\">.</span><span class=\"n\">T</span><span class=\"p\">)</span> <span class=\"o\">-</span> <span class=\"n\">np</span><span class=\"p\">.</span><span class=\"n\">eye</span><span class=\"p\">(</span><span class=\"n\">m</span><span class=\"p\">))</span>\n<span class=\"k\">print</span> <span class=\"s\">'</span><span class=\"se\">\\n</span><span class=\"s\"> S = '</span><span class=\"p\">,</span> <span class=\"n\">S</span><span class=\"p\">,</span> <span class=\"s\">'</span><span class=\"se\">\\n</span><span class=\"s\">'</span>\n<span class=\"k\">print</span> <span class=\"s\">'Frobenius norm of (VV^T - I) ='</span><span class=\"p\">,</span> \\\n    <span class=\"n\">LA</span><span class=\"p\">.</span><span class=\"n\">norm</span><span class=\"p\">(</span><span class=\"n\">V</span><span class=\"p\">.</span><span class=\"n\">dot</span><span class=\"p\">(</span><span class=\"n\">V</span><span class=\"p\">.</span><span class=\"n\">T</span><span class=\"p\">)</span> <span class=\"o\">-</span> <span class=\"n\">np</span><span class=\"p\">.</span><span class=\"n\">eye</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">))</span>\n</code></pre></div></div>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Frobenius norm of (UU^T - I) = 3.14018491737e-16\n\nS = [ 1.82891093  0.2125061 ]\n\nFrobenius norm of (VV^T - I) = 7.77403895378e-16\n</code></pre></div></div>\n<p>Lưu ý rằng biến <code class=\"language-plaintext highlighter-rouge\">S</code> được trả về chỉ bao gồm các phần tử trên đường chéo của \\(\\Sigma\\). Biến <code class=\"language-plaintext highlighter-rouge\">V</code> trả về là \\(\\mathbf{V}^T\\) trong \\((5)\\).</p>\n<p><a name=\"-compact-svd\"></a></p>\n<h3 id=\"33-compact-svd\">3.3. Compact SVD</h3>\n<p>Viết lại biểu thức \\((5)\\) dưới dạng tổng của các ma trận rank 1:\n\\[\n\\mathbf{A} = \\sigma_1 \\mathbf{u}_1 \\mathbf{v}^T_1 + \\sigma_2\\mathbf{u}_2\\mathbf{v}_2^2 + \\dots + \\sigma_r\\mathbf{u}_r\\mathbf{v}_r^T\n\\]</p>\n<p>với chú ý rằng mỗi \\(\\mathbf{u}_1 \\mathbf{v}^T_i, 1 \\leq i \\leq r\\) là một ma trận có rank bằng 1.</p>\n<p>Rõ ràng trong cách biểu diễn này, ma trận \\(\\mathbf{A}\\) chỉ phụ thuộc vào \\(r\\) cột đầu tiên của \\(\\mathbf{U, V}\\) và \\(r\\) giá trị khác 0 trên đường chéo của ma trận \\(\\Sigma\\). Vì vậy ta có một cách phân tích <em>gọn</em> hơn và gọi là <em>compact SVD</em>:</p>\n<p>\\[\n\\mathbf{A} = {\\mathbf{U}}_r{\\Sigma}_r({\\mathbf{V}}_r)^T\n\\]</p>\n<p>Với \\(\\mathbf{U}_r, \\mathbf{V}_r \\) lần lượt là ma trận được tạo bởi \\(r\\) cột đầu tiên của \\(\\mathbf{U}\\) và \\(\\mathbf{V}\\). \\(\\Sigma_r\\) là ma trận con được tạo bởi \\(r\\) hàng đầu tiên và \\(r\\) cột đầu tiên của \\(\\Sigma\\). Nếu ma trận \\(\\mathbf{A}\\) có rank nhỏ hơn rất nhiều so với số hàng và số cột \\(r \\ll m, n\\), ta sẽ được lợi nhiều về việc lưu trữ.</p>\n<p>Dưới đây là ví dụ minh hoạ với \\(m = 4, n = 6, r = 2\\).</p>\n<hr/>\n<div class=\"imgcap\">\n<img align=\"center\" src=\"/assets/26_svd/svd_truncated.png\" width=\"800\"/>\n</div>\n<div align=\"left\" class=\"thecap\">Hình 2: Biểu diễn SVD dạng thu gọn và biểu diễn ma trận dưới dạng tổng các ma trận có rank bằng 1.</div>\n<hr/>\n<p><a name=\"-truncated-svd\"></a></p>\n<h3 id=\"34-truncated-svd\">3.4. Truncated SVD</h3>\n<p>Chú ý rằng trong ma trận \\(\\Sigma\\), các giá trị trên đường chéo là không âm và giảm dần \\(\\sigma_1 \\geq \\sigma_2 \\geq \\dots, \\geq \\sigma_r \\geq 0 = 0 = \\dots = 0\\). Thông thường, chỉ một lượng nhỏ các \\(\\sigma_i\\) mang giá trị lớn, các giá trị còn lại thường nhỏ và gần 0. Khi đó ta có thể xấp xỉ ma trận \\(\\mathbf{A}\\) bằng tổng của \\(k &lt; r\\) ma trận có rank 1:</p>\n<p>\\[\n\\mathbf{A} \\approx \\mathbf{A}_k = \\mathbf{U}_k \\Sigma_k (\\mathbf{V}_k)^T = \\sigma_1 \\mathbf{u}_1 \\mathbf{v}^T_1 + \\sigma_2\\mathbf{u}_2\\mathbf{v}_2^2 + \\dots + \\sigma_k\\mathbf{u}_k\\mathbf{v}k^T ~~~~ (7)\n\\]\nDưới đây là một định lý thú vị. Định lý này nói rằng sai số do cách xấp xỉ trên chính là căn bậc hai của tổng bình phương của các singular values mà ta đã bỏ qua ở phần cuối của \\(\\Sigma\\). Ở đây sai số được định nghĩa là Frobineous norm của hiệu hai ma trận:</p>\n<hr/>\n<p><strong>Định lý:</strong>\n\\[\n||\\mathbf{A} - \\mathbf{A}_k||_F^2 = \\sum_{i = k + 1}^r \\sigma_i^2 ~~~ (8)\n\\]</p>\n<p><em>Chứng minh:</em></p>\n<p>Sử dụng tính chất \\(||\\mathbf{X}||_F^2 = \\text{trace}(\\mathbf{X}\\mathbf{X}^T)\\) và \\(\\text{trace}(\\mathbf{XY}) = \\text{trace}(\\mathbf{YX})\\) với mọi ma trận \\(\\mathbf{X, Y}\\) ta có:</p>\n<p>\\[\n\\begin{eqnarray}\n    ||\\mathbf{A} - \\mathbf{A}_k||_F^2 &amp; = &amp; ||\\sum_{i = k + 1}^r \\sigma_i \\mathbf{u}_i\\mathbf{v}_i^T ||_F^2    &amp; (9)\\newline\n    &amp; = &amp; \\text{trace}\\left\\{ \\left(\\sum_{i = k + 1}^r \\sigma_i \\mathbf{u}_i\\mathbf{v}_i^T\\right)\n    \\left(\\sum_{j = k + 1}^r \\sigma_j \\mathbf{u}_j\\mathbf{v}_j^T\\right)^T\n    \\right\\} &amp; (10) \\newline\n    &amp;=&amp; \\text{trace}\\left\\{ \\sum_{i = k + 1}^r \\sum_{j = k + 1}^r \\sigma_i\\sigma_j \\mathbf{u}_i\\mathbf{v}_i^T \\mathbf{v}_j \\mathbf{u}_j^T\n    \\right\\} &amp; (11) \\newline\n    &amp;=&amp; \\text{trace}\\left\\{ \\sum_{i = k + 1}^r  \\sigma_i^2\\mathbf{u}_i\\mathbf{u}_i^T\n    \\right\\} &amp; (12) \\newline\n    &amp;=&amp; \\text{trace}\\left\\{ \\sum_{i = k + 1}^r  \\sigma_i^2\\mathbf{u}_i^T\\mathbf{u}_i\n    \\right\\} &amp; (13) \\newline\n    &amp;=&amp; \\text{trace}\\left\\{ \\sum_{i = k + 1}^r  \\sigma_i^2\n    \\right\\} &amp; (14) \\newline\n    &amp; = &amp; \\sum_{i = k + 1}^r \\sigma_i^2 &amp; (15)\n\\end{eqnarray}\n\\]</p>\n<p>Dấu bằng ở \\((12)\\) là vì \\(\\mathbf{V}\\) là ma trận trực giao (xem \\((4)\\)).</p>\n<p>Dấu bằng ở \\((13)\\) là vì hàm \\(\\text{trace}\\) có tính chất giao hoán.</p>\n<p>Dấu bằng ở \\((15)\\) là vì biểu thức trong dấu ngoặc của \\((14)\\) là một số vô hướng.</p>\n<hr/>\n<p>Thay \\(k = 0\\) ta sẽ có:\n\\[||\\mathbf{A}||_F^2 = \\sum_{i = 1}^r \\sigma_i^2~~~~ (16) \\]</p>\n<p>Từ đó:</p>\n<p>\\[\n\\frac{||\\mathbf{A} - \\mathbf{A}_k||_F^2}{||\\mathbf{A}||_F^2} = {\\frac{\\sum_{i = k + 1}^r \\sigma_i^2}{\\sum_{j = 1}^r \\sigma_j^2}} ~~~~ (17)\n\\]</p>\n<p>Như vậy, <strong>sai số do xấp xỉ càng nhỏ nếu phần singular values bị <em>truncated</em> có giá trị càng nhỏ so với phần singular values được giữ lại.</strong> Đây là một định lý quan trọng giúp xác định việc xấp xỉ ma trận dựa trên lượng thông tin muốn giữ lại.</p>\n<p>Ví dụ, nếu ta muốn giữ lại ít nhất 90% lương thông tin trong \\(\\mathbf{A}\\), trước hết ta tính \\(\\sum_{j = 1}^r \\sigma_j^2\\), sau đó chọn \\(k\\) là số nhỏ nhất sao cho:</p>\n<p>\\[\n\\frac{\\sum_{i = 1}^k \\sigma_i^2}{\\sum_{j = 1}^r \\sigma_j^2} \\geq 0.9\n\\]</p>\n<p>Khi \\(k\\) nhỏ, ma trận \\(\\mathbf{A}_k\\) có rank là \\(k\\), là một ma trận có rank nhỏ. Vì vậy, Truncated SVD còn được coi là một phương pháp <em>Low-rank approximation</em>.</p>\n<p><a name=\"-best-rank-\\\\k\\\\-approximation\"></a></p>\n<h3 id=\"35-best-rank-k-approximation\">3.5. Best Rank \\(k\\) Approximation</h3>\n<p>Người ta chứng minh được rằng (<a href=\"https://www.cs.princeton.edu/courses/archive/spring12/cos598C/svdchapter.pdf\">Singular Value Decomposition - Princeton</a>) \\(\\mathbf{A}_k\\) chính là nghiệm của bài toán tối ưu:</p>\n<p>\\[\n\\begin{eqnarray}\n\\min_{\\mathbf{B}} &amp;&amp;||\\mathbf{A} - \\mathbf{B}||_F \\newline\n\\text{s.t.} &amp;&amp; \\text{rank}(\\mathbf{B}) = k ~~~~~~~~~~~~~~ (17)\n\\end{eqnarray}\n\\]</p>\n<p>và như đã chứng minh ở trên \\(||\\mathbf{A} - \\mathbf{A}_k||_F^2 = \\sum_{i = k + 1}^r \\sigma_i^2\\).</p>\n<p>Nếu sử dụng norm 2 của ma trận thay vì Frobenius norm để đo sai số, \\(\\mathbf{A}_k\\) cũng là nghiệm của bài toán tối ưu:</p>\n<p>\\[\n\\begin{eqnarray}\n\\min_{\\mathbf{B}} &amp;&amp;||\\mathbf{A} - \\mathbf{B}||_2 \\newline\n\\text{s.t.} &amp;&amp; \\text{rank}(\\mathbf{B}) = k ~~~~~~~~~~~~~~ (18)\n\\end{eqnarray}\n\\]</p>\n<p>và sai số: \\(||\\mathbf{A} - \\mathbf{A}_k||_2^2 = \\sigma_{k+1}^2\\).\nĐịnh nghĩa của norm 2 của một ma trận là:</p>\n<p>\\[\n||\\mathbf{A}||_2 = \\max_{||\\mathbf{x}||_2 = 1} ||\\mathbf{Ax}||_2\n\\]</p>\n<p>Đây là lý do căn bậc hai của tổng bình phương của các phần tử của một ma trận không được gọi là norm 2 như đối với vector.</p>\n<p>Nếu bạn muốn biết thêm:\n\\[\n||\\mathbf{A}||_2 = \\sigma_1\n\\]\ntức norm 2 của một ma trận chính là singular value lớn nhất của ma trận đó.</p>\n<p><strong>Frobenius norm và norm 2 là hai norms được sử dụng nhiều nhất trong ma trận. Như vậy, xét trên cả hai norm này, Truncated SVD đều cho xấp xỉ tốt nhất. Vì vậy Truncated SVD còn được gọi là Best low-rank Approximation.</strong></p>\n<p><a name=\"-mot-vai-ung-dung-cua-svd\"></a></p>\n<h2 id=\"4-một-vài-ứng-dụng-của-svd\">4. Một vài ứng dụng của SVD</h2>\n<p><a name=\"-image-compression\"></a></p>\n<h3 id=\"41-image-compression\">4.1. Image Compression</h3>\n<p>Xét ví dụ trong Hình 3 dưới đây:</p>\n<hr/>\n<div>\n<table style=\"border: 0px solid white\" width=\"100%\">\n<tr>\n<td align=\"center\" style=\"border: 0px solid white\" width=\"40%\">\n<img src=\"/assets/26_svd/original.png\" style=\"display:block;\" width=\"100%\"/>\n<br>\n        a)\n         </br></td>\n<td align=\"center\" style=\"border: 0px solid white\" width=\"40%\">\n<img src=\"/assets/26_svd/singular_value.png\" style=\"display:block;\" width=\"100%\"/>\n<br>\n        b)\n        </br></td>\n</tr>\n<tr>\n<td align=\"center\" style=\"border: 0px solid white\" width=\"40%\">\n<img src=\"/assets/26_svd/energy_preserved.png\" style=\"display:block;\" width=\"100%\"/>\n<br>\n        c)\n         </br></td>\n<td align=\"justify\" style=\"border: 0px solid white\" width=\"40%\">\n        Hình 3: Ví dụ về SVD cho ảnh. a) Bức ảnh gốc là 1 ảnh xám, là một ma trận cỡ \\(960 \\times 1440\\). b) Giá trị của các singular values của ma trận ảnh theo logscale. Có thể thấy rằng các singular value giảm nhanh ở khoảng \\(k = 200\\). c) Biểu diễn lượng thông tin được giữ lại khi chọn các \\(k\\) khác nhau. Có thể nhận thấy từ khoảng \\(k = 200\\), lượng thông tin giữ lại là gần bằng 1. Vậy ta có thể xấp xỉ ma trận ảnh này bằng 1 ma trận có rank nhỏ hơn.\n\n        </td>\n</tr>\n</table>\n</div>\n<hr/>\n<p>Hình 3 mô tả chất lượng ảnh khi chọn các giá trị \\(k\\) khác nhau. Khi \\(k\\) gần 100, lượng thông tin mất đi rơi vào khoảng nhỏ hơn 2%, ảnh thu được có chất lượng gần như ảnh gốc.</p>\n<hr/>\n<div class=\"imgcap\">\n<img align=\"center\" src=\"/assets/26_svd/img_compress.gif\" width=\"800\"/>\n</div>\n<div align=\"left\" class=\"thecap\">Hình 4: Ảnh thu được với các giá trị \\(k\\) khác nhau. Khi \\(k\\) tới gần 100, chất lượng ảnh gần như ảnh gốc.</div>\n<hr/>\n<p>Để lưu ảnh với Truncated SVD, ta sẽ lưu các ma trận \\(\\mathbf{U}_k \\in \\mathbb{R}^{m \\times k}, \\Sigma_k \\in \\mathbb{R}^{k \\times k}, \\mathbf{V}_k \\in \\mathbb{R}^{n \\times k}\\). Tổng số phần tử phải lưu là \\(k(m + n + 1)\\) với chú ý rằng ta chỉ cần lưu các giá trị trên đường chéo của \\(\\Sigma_k\\). Giả sử mỗi phần tử được lưu bởi một số thực 4 byte, thế thì số byte cần lưu trữ là \\(4k(m + n + 1)\\). Nếu so giá trị này với ảnh gốc có kích thước \\(mn\\), mỗi giá trị là 1 số nguyên 1 byte, tỉ lệ nén là:</p>\n<p>\\[\n\\frac{4k(m + n + 1)}{mn}\n\\]\nKhi \\(k \\ll m, n\\), ta được một tỉ lệ nhỏ hơn 1. Trong ví dụ của chúng ta \\(m = 960, n = 1440, k = 100\\), ta có tỉ lệ nén xấp xỉ 0.69, tức đã tiết kiệm được khoảng 30% bộ nhớ.</p>\n<p><a name=\"-truncated-svd-cho-recommendation-system\"></a></p>\n<h3 id=\"42-truncated-svd-cho-recommendation-system\">4.2. Truncated SVD cho Recommendation System</h3>\n<p>Như đã nhắc ở Mục 1, SVD là một phương pháp Matrix Factorization, vì vậy, nó cũng hoàn toàn có thể được áp dụng vào bài toán Recommendation Systems như trong Bài 25.</p>\n<p>Ý tưởng hoàn toàn tương tự, ta sẽ xấp xỉ Utility Matrix đã được chuẩn hoá (theo <em>user-based</em> hoặc <em>item-based</em>). Giá trị của ma trận xấp xỉ có rank nhỏ hơn chính là giá trị được dự đoán.</p>\n<p>Kết quả (RMSE) với cơ sở dữ liệu tương tự như Bài 25 là:</p>\n<ul>\n<li>\n<p>MovieLens 100k, user-based: 1.018 (tốt hơn so với 1.06 của Matrix Factorization).</p>\n</li>\n<li>\n<p>MovieLens 100k, item-based: 1.014 (tốt hơn so với 1.05)</p>\n</li>\n<li>\n<p>MovieLens 1M, item-based: 0.95 (tốt hơn so với 0.98)</p>\n</li>\n</ul>\n<p>Như vậy, Truncated SVD cho kết quả tốt hơn so với Matrix Factorization giải bằng Gradient Descent một chút.</p>\n<p>Một cách giải thích thú vị về mối liên quan giữa SVD và Utility Matrix với user-</p>\n<p><a name=\"-thao-luan\"></a></p>\n<h2 id=\"5-thảo-luận\">5. Thảo luận</h2>\n<ul>\n<li>\n<p>Ngoài hai ứng dụng nêu trên, SVD còn có mối liên quan chặt chẽ đến giả nghịch đảo Moore Penrose. (Xem thêm <a href=\"http://www.math.ucla.edu/~laub/33a.2.12s/mppseudoinverse.pdf\">The Moore-Penrose Pseudoinverse (Math 33A - UCLA)</a>). Giả nghịch đảo đóng một vài trò quan trọng trong giải hệ phương trình tuyến tính. Một ví dụ của nó đã được đề cập trong <a href=\"/2016/12/28/linearregression/#nghiem-cho-bai-toan-linear-regression\">Bài 3: Linear Regression</a>.</p>\n</li>\n<li>\n<p>Còn nhiều tính chất và ứng dụng thú vị khác của SVD, chúng ta sẽ dần tìm hiểu. Trước tiên là trong Dimensionality Reduction với Principle Component Analysis. Chúng ta sẽ cùng trao đổi tới vấn đề này trong bài tiếp theo.</p>\n</li>\n<li>\n<p>Khi ma trận \\(\\mathbf{A}\\) lớn, việc tính toán SVD của nó tốn nhiều thời gian. Cách tính Truncated SVD với \\(k\\) nhỏ bằng cách tính SVD như tôi sử dụng trong bài trở nên không khả thi. Thay vào đó, có một phương pháp lặp giúp tính các trị riêng và vector riêng của một ma trận lớn một cách hiệu quả, và ta chỉ cần tìm \\(k\\) trị riêng lớn nhất của \\(\\mathbf{AA}^T\\) và các vector riêng tương ứng, việc này sẽ tiết kiệm được khá nhiều thời gian. Bạn đọc có thể tìm đọc thêm <a href=\"http://college.cengage.com/mathematics/larson/elementary_linear/5e/students/ch08-10/chap_10_3.pdf\">Power method for approximating eigenvalues</a>. Phương pháp này cũng là phần chính của thuật toán nổi tiếng <a href=\"https://en.wikipedia.org/wiki/PageRank\">Google PageRank</a>, tôi sẽ có một bài về vấn đề này khi thấy phù hợp.</p>\n</li>\n<li>\n<p><a href=\"https://github.com/tiepvupsu/tiepvupsu.github.io/tree/master/assets/26_svd/python\">Source code</a></p>\n</li>\n</ul>\n<p><a name=\"-tai-lieu-tham-khao\"></a></p>\n<h2 id=\"6-tài-liệu-tham-khảo\">6. Tài liệu tham khảo</h2>\n<p>[1] <a href=\"https://www.youtube.com/watch?v=P5mlg91as1c\">Singular Value Decomposition - Stanford University</a></p>\n<p>[2] <a href=\"https://www.cs.princeton.edu/courses/archive/spring12/cos598C/svdchapter.pdf\">Singular Value Decomposition - Princeton</a></p>\n<p>[3] <a href=\"http://theory.stanford.edu/~tim/s15/l/l9.pdf\">CS168: The Modern Algorithmic Toolbox Lecture #9: The Singular Value Decomposition (SVD) and Low-Rank Matrix Approximations - Stanford</a></p>\n<p>[4] <a href=\"http://www.math.ucla.edu/~laub/33a.2.12s/mppseudoinverse.pdf\">The Moore-Penrose Pseudoinverse (Math 33A - UCLA)</a></p>\n</hr>"}}