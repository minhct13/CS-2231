{"topic": "<ul class=\"tags\">\n<a class=\"tag\" href=\"/tags#General\">General</a>\n<a class=\"tag\" href=\"/tags#Feature-extraction\">Feature-extraction</a>\n</ul>", "title": "<h1 class=\"post-title\" itemprop=\"name\">Bài 11: Giới thiệu về Feature Engineering</h1>", "introduction": {"title": "<h2 id=\"1-giới-thiệu\">1. Giới thiệu</h2>", "content": "<p>Cho tới lúc này, tôi đã trình bày 5 thuật toán Machine Learning cơ bản: <a href=\"/2016/12/28/linearregression/\">Linear Regression</a>, <a href=\"/2017/01/01/kmeans/\">K-means Clusterning</a>, <a href=\"/2017/01/08/knn/\">K-nearest neighbors</a>, <a href=\"/2017/01/21/perceptron/\">Perceptron Learning Algorithm</a> và <a href=\"/2017/01/27/logisticregression/\">Logistic Regression</a>. Trong tất cả các thuật toán này, tôi đều giả sử các điểm dữ liệu được biểu diễn bằng các vector, được gọi là <em>feature vector</em> hay <em>vector đặc trưng</em>, có độ dài bằng nhau, và cùng là vector cột hoặc vector hàng. Tuy nhiên, trong các bài toán thực tế, mọi chuyện không được tốt đẹp như vậy!</p><p>Với các bài toán về Computer Vision, các bức ảnh là các ma trận có kích thước khác nhau. Thậm chí để nhận dạng vật thể trong ảnh, ta cần thêm một bước nữa là <em>object detection</em>, tức là tìm cái khung chứa vật thể chúng ta cần dự đoán. Ví dụ, trong bài toán nhận dạng khuôn mặt, chúng ta cần tìm được vị trí các khuôn mặt trong ảnh và <em>crop</em> các khuôn mặt đó trước khi làm các bước tiếp theo. Ngay cả khi đã xác định được các khung chứa các khuôn mặt (và có thể resize các khung đó về cùng một kích thước), ta vẫn phải làm rất nhiều việc nữa vì hình ảnh của khuôn mặt còn phụ thưộc vào góc chụp, ánh sáng, … và rất nhiều yếu tố khác nữa.</p><p>Các bài toán NLP (Natural Language Processing - Xử lý ngôn ngữ tự nhiên) cũng có khó khăn tương tự khi độ dài của các văn bản là khác nhau, thậm chí có những từ rất hiếm gặp hoặc không có trong từ điển. Cũng có khi thêm một vài từ vào văn bản mà nội dung của văn bản không đổi hoặc hoàn toàn mang nghĩa ngược lại. Hoặc cùng là một câu nói nhưng tốc độ, âm giọng của mỗi người là khác nhau, thậm chí của cùng một người nhưng lúc ốm lúc khỏe cũng khác nhau.</p><p>Khi làm việc với các bài toán Machine Learning thực tế, nhìn chung chúng ta chỉ có được dữ liệu thô (raw) chưa qua chỉnh sửa, chọn lọc. Chúng ta cần phải tìm một phép biến đổi để loại ra những dữ liệu nhiễu (noise), và để đưa dữ liệu thô với số chiều khác nhau về cùng một chuẩn (cùng là các vector hoặc ma trận). Dữ liệu chuẩn mới này phải đảm bảo giữ được những thông tin đặc trưng (features) cho dữ liệu thô ban đầu. Không những thế, tùy vào từng bài toán, ta cần <em>thiết kế</em> những phép biến đổi để có những features phù hợp. Quá trình quan trọng này được gọi là <em>Feature Extraction</em>, hoặc <em>Feature Engineering</em>, một số tài liệu tiếng Việt gọi nó là <em>trích chọn đặc trưng</em>.</p><p>Tôi xin trích một câu nói của thầy Andrew Ng và xin phép thêm không dịch ra tiếng Việt (Nguồn <a href=\"https://en.wikipedia.org/wiki/Feature_engineering\">Feature Engineering - wiki</a>):</p><blockquote>\n<p>Coming up with features is difficult, time-consuming, requires expert knowledge. “Applied machine learning” is basically feature engineering.</p>\n</blockquote><p>Để giúp các bạn có cái nhìn tổng quan hơn, trong phần tiếp theo tôi xin đặt bước Feature Engineering này trong một bức tranh lớn hơn.</p><p><a name=\"-mo-hinh-chung-cho-cac-bai-toan-machine-learning\"></a></p>"}, "formulas": {"title": "<h2 id=\"2-mô-hình-chung-cho-các-bài-toán-machine-learning\">2. Mô hình chung cho các bài toán Machine Learning</h2>", "content": "<p>Phần lớn các bài toán Machine Learning có thể được thể hiện trong hình vẽ dưới đây:</p><div class=\"imgcap\">\n<img align=\"center\" src=\"\\assets\\FeatureEngineering\\ML_models.png\" width=\"800\"/>\n<div class=\"thecap\">Hình 1: Mô hình chung cho các bài toán Machine Learning.</div>\n</div><p>Có hai phases lớn là Training phase và Testing phase. Xin nhắc lại là với các bài toán Supervised learning, ta có các cặp dữ liệu (<em>input, output</em>), với các bài toán Unsupervised learing, ta chỉ có <em>input</em> mà thôi.</p><p><a name=\"training-phase\"></a></p><h3 id=\"training-phase\">TRAINING PHASE</h3><p>Có hai khối có nền màu xanh lục chúng ta cần phải thiết kế:</p><p><a name=\"feature-extractor\"></a></p><h4 id=\"feature-extractor\">Feature Extractor</h4><p><strong>ĐẦU RA</strong></p><p>Tôi xin đề cập đầu ra của khối này trước vì mục đích của Feature Engineering là tạo ra một Feature Extractor biến dữ liệu thô ban đầu thành dữ liệu phù hợp với từng mục đích khác nhau.</p><p><strong>ĐẦU VÀO</strong></p><ul>\n<li>\n<p><strong><em>raw training input</em></strong>. Raw input là tất cả các thông tin ta biết về dữ liệu. Ví dụ: với ảnh thì là giá trị của từng pixel; với văn bản thì là từng từ, từng câu; với file âm thanh thì nó là một đoạn tín hiệu; với cơ sở dữ liệu <a href=\"/2017/01/08/knn/#bo-co-so-du-lieu-iris-iris-flower-dataset\">Iris</a> thì nó là độ dài các cánh hoa và đài hoa, … Dữ liệu thô này thường không ở dạng vector, không có số chiều như nhau. Thậm chí có thể có số chiều như nhau nhưng số chiều quá lớn, như một bức ảnh màu 1000 pixel x 1000 pixel thì số <em>elements</em> đã là \\(3 \\times 10^6\\) (3 vì ảnh màu thường có 3 channels: Red, Green, Blue). Đây là một con số quá lớn, không lợi cho lưu trữ và tính toán.</p>\n</li>\n<li>\n<p><strong>(optional) <em>output</em> của <em>training set</em></strong>. Trong các bài toán Unsupervised\nlearning, ta không biết <em>output</em> nên hiển nhiên sẽ không có đầu vào này. Trong\ncác bài toán Supervised learning, có khi dữ liệu này cũng không được sử dụng.\nVí dụ: nếu <em>raw input</em> đã có cùng số chiều rồi nhưng số chiều quá lớn,  ta\nmuốn giảm số chiều của nó thì cách đơn giản nhất là <em>chiếu</em> vector đó xuống\nmột không gian có số chiều nhỏ hơn bằng cách lấy một ma trận ngẫu nhiên nhân\nvới nó. Ma trận này thường là ma trận <em>béo</em> (số hàng ít hơn số cột, tiếng Anh - fat matrices) để đảm bảo số chiều thu được nhỏ hơn số chiều ban đầu. Việc\nlàm này mặc dù làm mất đi thông tin, trong nhiều trường hợp vẫn mang lại hiệu\nquả vì đã giảm được lượng tính toán ở phần sau. Đôi khi <em>ma trận chiếu</em> không\nphải là ngẫu nhiên mà có thể được <em>học</em> dựa trên toàn bộ <em>raw input</em>, ta sẽ có\nbài toán tìm ma trận chiếu để lượng thông tin mất đi là ít nhất. Trong nhiều\ntrường hợp, dữ liệu <em>output</em> của <em>training set</em> cũng được sử dụng để tạo ra\nFeature Extractor. Ví dụ: trong bài toán classification, ta không quan tâm\nnhiều đến việc mất thông tin hay không, ta chỉ quan tâm đến việc những thông\ntin còn lại có đặc trưng cho từng class hay không. Ví dụ, dữ liệu thô là các\nhình vuông và hình tam giác có màu đỏ và xanh. Trong bài toán phân loại đa\ngiác, các output là <em>tam giác</em> và <em>vuông</em>,  thì ta không quan tâm tới màu sắc\nmà chỉ quan tâm tới số cạnh của đa giác. Ngược lại, trong bài toán phân loại\nmàu, các class là <em>xanh</em> và <em>đỏ</em>, ta không quan tâm tới số cạnh mà chỉ quan\ntâm đến màu sắc thôi.</p>\n</li>\n<li>\n<p><strong>(optional) <em>Prior knowledge about data</em></strong>: Đôi khi những giả thiết khác về dữ liệu cũng mang lại lợi ích. Ví dụ, trong bài toán classification, nếu ta biết dữ liệu là (gần như) <a href=\"/2017/01/21/perceptron/#bai-toan-perceptron\"> <em>linearly separable</em></a> thì ta sẽ đi tìm một ma trận chiếu sao cho ở trong không gian mới, dữ liệu vẫn đảm bảo tính <em>linearly separable</em>, việc này thuận tiện hơn cho phần classification vì các thuật toán linear, nhìn chung, đơn giản hơn.</p>\n</li>\n</ul><p>Sau khi <em>học</em> được feature extractor thì ta cũng sẽ thu được <em>extracted features</em> cho <em>raw input data</em>. Những <em>extracted features</em> này được dùng để huấn luyện các thuật toán Classification, Clustering, Regression,… ở phía sau.</p><p><a name=\"main-algorithms\"></a></p><h4 id=\"main-algorithms\">Main Algorithms</h4><p>Khi có được <em>extracted features</em> rồi, chúng ta sử dụng những thông tin này cùng\nvới (optional) <em>training output</em> và (optional) <em>prior knowledge</em> để tạo ra các\nmô hình phù hợp, điều mà chúng ta đã làm ở những bài trước.</p><p><strong>Chú ý:</strong> Trong một số thuật toán cao cấp hơn, việc <em>huấn luyện</em> feature extractor và main algorithm được thực hiện cùng lúc với nhau chứ không phải từng bước như trên.</p><p><strong>Một điểm rất quan trọng: khi xây dựng bộ <em>feature extractor</em> và <em>main\nalgorithms</em>, chúng ta không được sử dụng bất kỳ thông tin nào trong tập <em>test\ndata</em>. Ta phải giả sử rằng những thông tin trong <em>test data</em> chưa được nhìn thấy\nbao giờ. Nếu sử dụng thêm thông tin về <em>test data</em> thì rõ ràng ta đã <em>ăn gian</em>!\nTôi từng đánh giá các bài báo khoa học quốc tế, rất nhiều tác giả xây dựng mô\nhình dùng cả dữ liệu <em>test data</em>, sau đó lại dùng chính mô hình đó để kiểm tra\ntrên <em>test data</em> đó. Việc <em>ăn gian</em> này là lỗi rất nặng và hiển nhiên những bài\nbáo đó bị từ chối (reject).</strong></p><p><a name=\"testing-phase\"></a></p><h3 id=\"testing-phase\">TESTING PHASE</h3><p>Bước này đơn giản hơn nhiều. Với <em>raw input</em> mới, ta sử dụng feature extractor\nđã tạo được ở trên (tất nhiên không được sử dụng <em>output</em> của nó vì <em>output</em> là\ncái ta đang đi tìm) để tạo ra feature vector tương ứng. Feature vector được đưa\nvào <em>main algorithm</em> đã được học ở training phase để dự đoán <em>output</em>.</p><p><a name=\"-mot-so-vi-du-ve-feature-engineering\"></a></p>"}, "examples": {"title": "<h2 id=\"3-một-số-ví-dụ-về-feature-engineering\">3. Một số ví dụ về Feature Engineering</h2>", "content": "<p><a name=\"truc-tiep-lay-raw-data\"></a></p><h3 id=\"trực-tiếp-lấy-raw-data\">Trực tiếp lấy raw data</h3><p>Với bài toán phân loại chữ số viết tay trong bộ cơ sở dữ liệu\n<a href=\"/2017/01/04/kmeans2/#bo-co-so-du-lieu-mnist\">MNIST</a>, mỗi bức ảnh có số chiều là\n28 pixel x 28 pixel (tất nhiên việc <em>crop</em> và chỉnh sửa mỗi bức ảnh đã được thực\nhiện từ trước rồi, đó đã là một phần của feature engineering rồi). Một cách đơn\ngiản thường được dùng là <em>kéo dài</em> ma trận 28x28 này để được 1 vector có số\nchiều 784. Trong cách này, các cột (hoặc hàng) của ma trận ảnh được đặt chồng\nlên (hoặc cạnh nhau) để được 1 vector dài. Vector dài này được trực tiếp sử dụng\nlàm feature đưa vào các bộ classifier/clustering/regression/… Lúc này, giá trị\ncủa mỗi pixel ảnh được coi là một feature.</p><p>Rõ ràng việc làm đơn giản này đã làm mất thông tin về <em>không gian</em> (spatial information) giữa các điểm ảnh, tuy nhiên, trong nhiều trường hợp, nó vẫn mang lại kết quả khả quan. \n<a name=\"feature-selection\"></a></p><h3 id=\"feature-selection\">Feature selection</h3><p>Giả sử rằng các điểm dữ liệu có số features khác nhau (do kích thước dữ liệu\nkhác nhau hay do một số feature mà điểm dữ liệu này có nhưng điểm dữ liệu kia\nlại không thu thập được), và số lượng features là cực lớn. Chúng ta cần <em>chọn</em>\nra một số lượng nhỏ hơn các feature phù hợp với bài toán. <em>Chọn thế nào</em> và <em>thế\nnào là phù hợp</em> lại là một bài toán khác, tôi sẽ không bàn thêm ở đây.</p><p><a name=\"dimensionality-reduction\"></a></p><h3 id=\"dimensionality-reduction\">Dimensionality reduction</h3><p>Một phương pháp nữa tôi đã đề cập đó là làm giảm số chiều của dữ liệu để giảm bộ\nnhớ và khối lượng tính toán. Việc giảm số chiều này có thể được thực hiện bằng\nnhiều cách, trong đó <em>random projection</em> là cách đơn giản nhất. Tức chọn một <em>ma\ntrận chiếu</em> (projection matrix) ngẫu nhiên (ma trận béo) rồi nhân nó với từng\nđiểm dữ liệu (giả sử dữ liệu ở dạng vector cột) để được các vector có số chiều\nthấp hơn. Ví dụ, vector ban đầu có số chiều là 784, chọn <em>ma trận chiếu</em> có kích\nthước (100x784), khi đó nếu nhân ma trận chéo này với vector ban đầu, ta sẽ được\nmột vector mới có số chiều là 100, nhỏ hơn số chiều ban đầu rất nhiều. Lúc này,\ncó thể ta không có tên gọi cho mỗi feature nữa vì các feature ở vector ban đầu\nđã được trộn lẫn với nhau theo một tỉ lệ nào đó rồi lưu vào vector mới này. Mỗi\nthành phần của vector mới này được coi là một feature (không tên).</p><p>Việc chọn một ma trận chiếu ngẫu nhiên đôi khi mang lại kết quả tệ không mong\nmuốn vì thông tin bị mất đi quá nhiều. Một phương pháp được sử dụng nhiều để hạn\nchế lượng thông tin mất đi có tên là <a href=\"https://en.wikipedia.org/wiki/Principal_component_analysis\">Principle Component\nAnalysis</a> sẽ được\ntôi trình bày sau đây khoảng 1-2 tháng.</p><p><strong>Chú ý:</strong> Feature learning không nhất thiết phải làm giảm số chiều dữ liệu, đôi\nkhi feature vector còn có số chiều lớn hơn raw data. Random projection cũng có\nthể làm được việc này nếu ma trận chiếu là một ma trận <em>cao</em> (số cột ít hơn số\nhàng).</p><p><a name=\"bag-of-words\"></a></p><h3 id=\"bag-of-words\">Bag-of-words</h3><p>Hẳn rất nhiều bạn đã tự đặt câu hỏi: Với một văn bản thì feature vector sẽ có\ndạng như thế nào? Làm sao đưa các từ, các câu, đoạn văn ở dạng <em>text</em> trong các\nvăn bản về một vector mà mỗi phần tử là một số?</p><p>Có một phương pháp rất phổ biến giúp bạn trả lời những câu hỏi này. Phương pháp đó có tên là <em>Bag of Words (BoW)</em> (<em>Túi đựng Từ</em>).</p><p>Vẫn theo thói quen, tôi bắt đầu bằng một ví dụ. Giả sử chúng ta có bài toán phân loại tin rác. Ta thấy rằng nếu một tin có chứa các từ <em>khuyến mại, giảm giá, trúng thưởng, miễn phí, quà tặng, tri ân, …</em> thì nhiều khả năng đó là một tin nhắn rác. Vậy phương pháp đơn giản nhất là <em>đếm</em> xem trong tin đó có bao nhiêu từ thuộc vào các từ trên, nếu nhiều hơn 1 ngưỡng nào đó thì ta quyết định đó là tin rác. (Tất nhiên bài toán thực tế phức tạp hơn nhiều khi các từ có thể được viết dưới dạng không dấu, hoặc bị cố tình viết sai chính tả, hoặc dùng ngôn ngữ teen). Với các loại văn bản khác nhau thì lượng từ liên quan tới từng chủ đề cũng khác nhau. Từ đó có thể dựa vào số lượng các từ trong từng loại để làm các vector đặc trưng cho từng văn bản.</p><p>Tôi xin lấy ví dụ cụ thể hơn về cách tạo ra vector đặc trưng cho mỗi văn bản dựa trên BoW và xin được lấy tiếng Anh làm ví dụ (nguồn <a href=\"https://en.wikipedia.org/wiki/Bag-of-words_model\">Bag of Words wiki</a>. Tiếng Việt khó hơn vì một từ có thể có nhiều âm tiết, tiếng Anh thì thường cứ gặp dấu cách là kết thúc một từ).</p><p>Giả sử chúng ta có hai văn bản đơn giản:</p><div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>(1) John likes to watch movies. Mary likes movies too.\n</code></pre></div></div><p>và</p><div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>(2) John also likes to watch football games.\n</code></pre></div></div><p>Dựa trên hai văn bản này, ta có danh sách các từ được sử dụng, được gọi là <em>từ điển</em> với 10 <em>từ</em> như sau:</p><div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>[\"John\", \"likes\", \"to\", \"watch\", \"movies\", \"also\", \"football\", \"games\", \"Mary\", \"too\"]\n</code></pre></div></div><p>Với mỗi văn bản, ta sẽ tạo ra một vector đặc trưng có số chiều bằng 10, mỗi phần tử đại diện cho số từ tương ứng xuất hiện trong văn bản đó. Với hai văn bản trên, ta sẽ có hai vector đặc trưng là:</p><div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>(1) [1, 2, 1, 1, 2, 0, 0, 0, 1, 1]\n(2) [1, 1, 1, 1, 0, 1, 1, 1, 0, 0]\n</code></pre></div></div><p>Văn bản (1) có 1 từ “John”, 2 từ “likes”, 0 từ “also”, 0 từ “football”, … nên ta thu được vector tương ứng như trên.</p><p>Có một vài điều cần lưu ý trong BoW:</p><ul>\n<li>\n<p>Với những ứng dụng thực tế, <em>từ điền</em> có nhiều hơn 10 từ rất nhiều, có thể đến một trăm nghìn hoặc cả triệu, như vậy vector đặc trưng thu được sẽ rất <em>dài</em>. Một văn bản chỉ có 1 câu, và 1 tiểu thuyết nghìn trang đều được biểu diễn bằng các vector có số chiều bằng 100 nghìn hoặc 1 triệu.</p>\n</li>\n<li>\n<p>Có rất nhiều từ trong từ điển không xuất hiện trong một văn bản. Như vậy các vector đặc trưng thu được thường có rất nhiều phần tử bằng 0. Các vector có nhiều phần tử bằng 0 được gọi là <em>sparse vector</em> (sparse hiểu theo nghĩa là <em>thưa thớt, rải rác</em>, tôi xin phép chỉ sử dụng khái niệm này bằng tiếng Anh). Để việc lưu trữ được hiệu quả hơn, ta không lưu cả vector đó mà chỉ lưu <em>vị trí</em> của các phần tử khác 0 và <em>giá trị</em> tương ứng. Lưu ý: nếu có hơn 50% số phần tử khác 0, việc làm này lại phản tác dụng!</p>\n</li>\n<li>\n<p>Thi thoảng có những từ hiếm gặp không nằm trong từ điển, vậy ta sẽ làm gì? Một cách thường được dùng là <em>mở rộng</em> vector đặc trưng thêm 1 phần tử, gọi là phẩn tử <code class=\"language-plaintext highlighter-rouge\">&lt;Unknown&gt;</code>. Mọi từ không có trong từ điền đều được coi là <code class=\"language-plaintext highlighter-rouge\">&lt;Unknown&gt;</code>.</p>\n</li>\n<li>\n<p>Nghĩ kỹ một chút, những từ hiếm đôi khi lại mang những thông tin quan trọng nhất mà chỉ loại văn bản đó có. Đây là một nhược điểm của BoW. Có một phương pháp cải tiến khác giúp khắc phục nhược điểm này có tên là Term Frequency-Inverse Document Frequency (TF-IDF) dùng để xác định tầm quan trọng của một từ trong một văn bản dựa trên toàn bộ văn bản trong cơ sở dữ liệu (corpus). Bạn đọc muốn tìm hiểu thêm có thể xem <a href=\"https://www.gitbook.com/book/lizrush/algorithms-for-webdevs-ebook/details\">5 Algorithms Every Web Developer Can Use and Understand, section 5.</a></p>\n</li>\n<li>\n<p>Nhược điểm lớn nhất của BoW là nó không mang thông tin về thứ tự của các từ. Cũng như sự liên kết giữa các câu, các đoạn văn trong văn bản. Ví dụ, ba câu sau đây: “<em>Em yêu anh không?</em>”, “<em>Em không yêu anh</em>”, và “<em>Không, (nhưng) anh yêu em</em>” khi được trích chọn đặc trưng bằng BoW sẽ cho ra ba vector giống hệt nhau, mặc dù ý nghĩa khác hẳn nhau.</p>\n</li>\n</ul><p><strong>Bonus:</strong> hình dưới đây là tần suất sử dụng các từ (coi mỗi âm tiết là một từ) trong Truyện Kiều (<a href=\"https://bitbucket.org/tiepvupsu/vietnamese/src/c6f3af6050f8ca911ed0fa209220ce3c99010075/TruyenKieu2.txt?at=master&amp;fileviewer=file-view-default\">theo bản này</a>) nếu ta chỉ sử dụng 30 từ có tần suất cao nhất. :</p><div class=\"imgcap\">\n<img align=\"center\" src=\"\\assets\\FeatureEngineering\\truyenkieu.png\" width=\"400\"/>\n<div class=\"thecap\">Hình 2: Bag of Words cho Truyện Kiều với 30 từ có tần suất cao nhất.</div>\n</div><p><a name=\"bag-of-words-trong-computer-vision\"></a></p><h3 id=\"bag-of-words-trong-computer-vision\">Bag-of-Words trong Computer Vision</h3><p>Bags of Words cũng được áp dụng trong Computer Vision với cách định nghĩa <em>words</em> và từ điển khác.</p><p>Xét các ví dụ sau:</p><p><strong>Ví dụ 1:</strong></p><p>Có hai class ảnh, một class là ảnh các khu rừng, một class là ảnh các sa mạc. Phân loại một bức ảnh là rừng hay sa mạc (giả sử ta biết rằng nó thuộc một trong hai loại này) một cách trực quan nhất là dựa vào màu sắc. Màu xanh nhiều thì là rừng, màu đỏ và vàng nhiều thì là sa mạc. Vậy chúng ta có thể có một mô hình đơn giản để trích chọn đặc trưng như sau:</p><ul>\n<li>\n<p>Với một bức ảnh, chuẩn bị một vector \\(\\mathbf{x}\\) có số chiều bằng 3, đại diện cho 3 màu xanh (\\(x_1\\)), đỏ (\\(x_2\\)), và vàng (\\(x_3\\)).</p>\n</li>\n<li>\n<p>Với mỗi điểm ảnh trong bức ảnh đó, xem nó gần với màu xanh, đỏ hay vàng nhất dựa trên giá trị của pixel đó. Nếu nó gần điểm xanh nhất, tăng \\(x_1\\) lên 1; gần đỏ nhất, tăng \\(x_2\\) lên 1; gần vàng nhất, tăng \\(x_3\\) lên 1.</p>\n</li>\n<li>\n<p>Sau khi xem xét tất cả các điểm ảnh, dù cho bức ảnh có kích thước thế nào, ta vẫn thu được một vector có độ dài bằng 3, mỗi phần tử thể hiện việc có bao nhiêu pixel trong bức ảnh có màu tương ứng. Vector cuối này còn được gọi là vector histogram của bức ảnh tương ứng với ba màu xanh, đỏ, vàng. Dựa vào vector này, ta có thể quyết định bức ảnh đó là ảnh rừng hay sa mạc.</p>\n</li>\n</ul><p><strong>Ví dụ 2:</strong></p><p>Trên thực tế, các bài toán xử lý ảnh không đơn giản như ví dụ 1 trên đây. Mắt người thực ra nhạy với các đường nét, hình dáng hơn là màu sắc. Một cái (ảnh) cây dù không có màu vẫn là một cái (ảnh) cây! Vì vậy, xem xét giá trị từng điểm ảnh một không mang lại kết quả khả quan vì lượng thông tin bị mất quá nhiều.</p><p>Có một cách khắc phục là thay vì xem xét một điểm ảnh, ta xem xét một <em>cửa sổ</em> nhỏ trong ảnh (trong Computer Vision, cửa sổ này được gọi là patch) là một hình chữ nhật chứa nhiều điểm ảnh gần nhau. Cửa sổ này đủ lớn để có thể chứa được các bộ phận có thể mô tả được vật thể trong ảnh.</p><p>Ví dụ với mặt người, các patch nên đủ lớn để chứa được các phần của khuôn mặt như mắt, mũi, miệng như hình dưới đây.</p><div class=\"imgcap\">\n<img align=\"center\" src=\"\\assets\\FeatureEngineering\\bow_face.png\" width=\"800\"/>\n<div class=\"thecap\">Hình 3: Bag of Words cho ảnh chứa mặt người. (Nguồn <a href=\"http://www.robots.ox.ac.uk/~az/icvss08_az_bow.pdf\"> Bag of visual words model: recognizing object categories</a>)</div>\n</div><p>Tương tự thế, với ảnh là ô tô, các patch thu được có thể là bánh xe, khung xe, cửa xe, … như hàng trên trong hình dưới đây.</p><div class=\"imgcap\">\n<img align=\"center\" src=\"\\assets\\FeatureEngineering\\bow_car.png\" width=\"800\"/>\n<div class=\"thecap\">Hình 4: Bag of Words cho ảnh ô tô. (Nguồn: tôi cố gắng tìm nguồn cho hình này nhưng tất cả các tài liệu tôi tìm được đều ghi \"Source: B. Leibe\", tôi cũng xin được trích nguồn tương tự)</div>\n</div><p>Có một câu hỏi đặt ra là, trong xử lý văn bản, hai từ được coi là như nhau nếu nó được biểu diễn bởi các ký tự giống nhau. Vậy trong xử lý ảnh, hai patches được coi là như nhau khi nào? Khi mọi pixel trong hai patches có giá trị bằng nhau sao?</p><p>Câu trả lời là không. Xác suất để hai patches giống hệt nhau từng pixel là rất thấp vì có thể một phần của vật thể trong một patch bị lệch đi vài pixel so với phần đó trong patch kia; hoặc phần vật thể trong patch bị méo, hoặc có độ sáng khác nhau, mặc dù ta vẫn nhìn thấy hai patches đó <em>rất giống nhau</em>. Vậy thì hai patch được coi là như nhau khi nào? Và <em>từ điển</em> ở đây được định nghĩa như thế nào?</p><p>Câu trả lời ngắn: hai patches là gần giống nhau nếu khoảng cách Euclid giữa hai vector tạo bởi hai patches đó gần nhau. Từ điển (codebook) sẽ có số phần tử do ta tự chọn. Số phần tử càng cao thì độ sai lệch càng ít, nhưng sẽ nặng về tính toán hơn.</p><p>Câu trả lời dài: chúng ta có thể áp dụng <a href=\"/2017/01/01/kmeans/\">K-means clustering</a>. Với rất nhiều patches thu được, giả sử ta muốn xây dựng một <em>codebook</em> với chỉ khoảng 1000 <em>words</em>. Vậy thì ta cho \\(k = 1000\\) rồi thực hiện K-means clustering trên toàn bộ số patches thu được (từ tập training). Sau khi thực hiện K-means clustering, ta thu được 1000 clusters và 1000 centers tương ứng. Mỗi centers này được coi là một <em>words</em>, và tất cả những điểm rơi vào cùng một cluster được coi là cùng một bag. Với ảnh trong tập test data, ta cũng lấy các patches rồi xem chúng rơi vào những bags nào. Từ đó suy ra vector đặc trưng cho mỗi bức ảnh. Chú ý rằng với \\(k = 1000\\), mỗi bức ảnh sẽ được <em>mô tả</em> bởi một vector có số chiều 1000, tức là mỗi điểm dữ liệu bây giờ đã có số chiều bằng nhau, mặc dù ảnh thô đầu vào có thể có kích thước khác nhau.\n<a name=\"feature-scaling-and-normalization\"></a></p><h3 id=\"feature-scaling-and-normalization\">Feature Scaling and Normalization</h3><p>(Tham khảo <a href=\"https://en.wikipedia.org/wiki/Feature_scaling\">Feature Scaling wiki</a>).</p><p>Các điểm dữ liệu đôi khi được đo đạc với những đơn vị khác nhau, m và feet chẳng hạn. Hoặc có hai thành phần (của vector dữ liệu) chênh lệch nhau quá lớn, một thành phần có khoảng giá trị từ 0 đến 1000, thành phần kia chỉ có khoảng giá trị từ 0 đến 1 chẳng hạn. Lúc này, chúng ta cần chuẩn hóa dữ liệu trước khi thực hiện các bước tiếp theo.</p><p><strong>Chú ý:</strong> việc chuẩn hóa này chỉ được thực hiện khi vector dữ liệu đã có cùng chiều.</p><p>Một vài phương pháp chuẩn hóa thường dùng:\n<a name=\"rescaling\"></a></p><h4 id=\"rescaling\">Rescaling</h4><p>Phương pháp đơn giản nhất là đưa tất cả các thành phần về cùng một khoảng, \\([0, 1]\\) hoặc \\([-1, 1]\\) chẳng hạn, tùy thuộc vào ứng dụng. Nếu muốn đưa một thành phần (feature) về khoảng \\([0, 1]\\), công thức sẽ là: \n\\[\nx’ = \\frac{x - \\min(x)}{\\max(x) - \\min(x)}\n\\]\ntrong đó \\(x\\) là giá trị ban đầu, \\(x’\\) là giá trị sau khi chuẩn hóa. \\(\\min(x), \\max(x)\\) được tính trên toàn bộ dữ liệu training data ở cùng một thành phần. Việc này được thực hiện trên từng thành phần của vector dữ liệu \\(\\mathbf{x}\\).</p><p><a name=\"standardization\"></a></p><h4 id=\"standardization\">Standardization</h4><p>Một phương pháp nữa cũng hay được sử dụng là giả sử mỗi thành phần đều có phân phối chuẩn với kỳ vọng là 0 và phương sai là 1. Khi đó, công thức chuẩn hóa sẽ là: \n\\[\nx’ = \\frac{x - \\bar{x}}{\\sigma}\n\\]\nvới \\(\\bar{x}, \\sigma\\) lần lượt là kỳ vọng và phương sai (standard deviation) của thành phần đó trên toàn bộ training data. \n<a name=\"scaling-to-unit-length\"></a></p><h4 id=\"scaling-to-unit-length\">Scaling to unit length</h4><p>Một lựa chọn khác nữa cũng được sử dụng rộng rãi là chuẩn hóa các thành phần của mỗi vector dữ liệu sao cho toàn bộ vector có độ lớn (Euclid, tức <a href=\"/math/#norm2\">norm 2</a>) bằng 1. Việc này có thể được thực hiện bằng:\n\\[\n\\mathbf{x}’ = \\frac{\\mathbf{x}}{||\\mathbf{x}||_2}\n\\]</p><p><a name=\"-thao-luan\"></a></p>"}}