{"topic": "<ul class=\"tags\">\n<a class=\"tag\" href=\"/tags#Neural-nets\">Neural-nets</a>\n<a class=\"tag\" href=\"/tags#Supervised-learning\">Supervised-learning</a>\n<a class=\"tag\" href=\"/tags#Regression\">Regression</a>\n<a class=\"tag\" href=\"/tags#Binary-classifier\">Binary-classifier</a>\n<a class=\"tag\" href=\"/tags#Multi-class\">Multi-class</a>\n<a class=\"tag\" href=\"/tags#AR\">AR</a>\n<a class=\"tag\" href=\"/tags#MNIST\">MNIST</a>\n</ul>", "title": "<h1 class=\"post-title\" itemprop=\"name\">Bài 12: Binary Classifiers cho các bài toán Classification</h1>", "introduction": {"title": "<h2 id=\"1-bài-toán-phân-biệt-giới-tính-dựa-trên-ảnh-khuôn-mặt\">1. Bài toán phân biệt giới tính dựa trên ảnh khuôn mặt</h2>", "content": "<p>Chúng ta cùng bắt đầu với bài toán phân biệt giới tính dựa trên ảnh khuôn mặt. Về ảnh khuôn mặt, bộ cơ sở dữ liệu <a href=\"http://www2.ece.ohio-state.edu/~aleix/ARdatabase.html\">AR Face Database</a> được sử dụng rộng rãi.</p><p>Bộ cơ sở dữ liệu này bao gồm hơn 4000 ảnh màu tương ứng với khuôn mặt của 126 người (70 nam, 56 nữ). Với mỗi người, 26 bức ảnh được chụp ở các điều kiện ánh sáng khác nhau, sắc thái biểu cảm khuôn mặt khác nhau, và bị che mắt (bởi kính râm) hoặc miệng (bởi khăn); và được chụp tại hai thời điểm khác nhau cách nhau 2 tuần.</p><p>Để cho đơn giản, tôi sử dụng bộ cơ sử AR Face thu gọn (có thể tìm thấy trong cùng trang web phía trên, mục <em>Other (relevant) downloads</em>). Bộ cơ sở dữ liệu thu gọn này bao gồm 2600 bức ảnh từ 50 nam và 50 nữ. Hơn nữa, các khuôn mặt cũng đã được xác định chính xác và được <em>cropped</em> với kích thước 165 x 120 (pixel) bằng phương pháp được mô tả trong bài báo <a href=\"http://lectures.molgen.mpg.de/networkanalysis13/PCAversusLDA_eigenfaces.pdf\">PCA veus LDA</a>. Tôi xin bỏ qua phần xử lý này và trực tiếp sử dụng ảnh đã cropped như một số ví dụ dưới đây:</p><div class=\"imgcap\">\n<img align=\"center\" src=\"\\assets\\LogReg2\\ARgender.png\" width=\"800\"/>\n<div class=\"thecap\">Hình 1: Các ví dụ mẫu trong AR Face database thu gọn.</div>\n</div><p><strong>Lưu ý:</strong></p><ul>\n<li>\n<p><em>Vì lý do bản quyền, tôi không được phép chia sẻ với các bạn bộ dữ liệu này. Các bạn muốn sở hữu có thể liên lạc với tác giả như hướng dẫn ở trong website <a href=\"http://www2.ece.ohio-state.edu/~aleix/ARdatabase.html\">AR Face Database</a>. Một khi các bạn đã có tài khoản để download, tôi mong các bạn tôn trọng tác giả và không chia sẻ trực tiếp với bạn bè.</em></p>\n</li>\n<li>\n<p><em>Có một cách đơn giản và nhanh hơn để lấy được các feature vector (sau bước <a href=\"/general/2017/02/06/featureengineering/\">Feature Engineering</a>)  của cơ sở dữ liệu này mà không cần liên lạc với tác giả. Các bạn có thể tìm  <a href=\"https://www.umiacs.umd.edu/~zhuolin/projectlcksvd.html\">tại đây</a>, phần <strong>Downloads</strong>, mục <strong>Random face features for AR database</strong>.</em></p>\n</li>\n</ul><p>Mỗi bức ảnh trong AR Face thu gọn được đặt tên dưới dạng <code class=\"language-plaintext highlighter-rouge\">G-xxx-yy.bmp</code> Trong đó: <code class=\"language-plaintext highlighter-rouge\">G</code> nhận một trong hai giá trị <code class=\"language-plaintext highlighter-rouge\">M</code> (man) hoặc <code class=\"language-plaintext highlighter-rouge\">W</code> (woman); <code class=\"language-plaintext highlighter-rouge\">xxx</code> là id của người, nhận gía trị từ <code class=\"language-plaintext highlighter-rouge\">001</code> đến <code class=\"language-plaintext highlighter-rouge\">050</code>; <code class=\"language-plaintext highlighter-rouge\">yy</code> là điều kiện chụp, nhận giá trị từ <code class=\"language-plaintext highlighter-rouge\">01</code> đến <code class=\"language-plaintext highlighter-rouge\">26</code>, trong đó các điều kiện có số thứ tự từ <code class=\"language-plaintext highlighter-rouge\">01</code> đến <code class=\"language-plaintext highlighter-rouge\">07</code> và từ <code class=\"language-plaintext highlighter-rouge\">14</code> đến <code class=\"language-plaintext highlighter-rouge\">20</code> là các khuôn mặt không bị che bởi kính hoặc khăn. Tôi tạm gọi mỗi <em>điều kiện</em> này là một <em>view</em>.</p><p>Để làm ví dụ cho thuật toán Logistic Regression, tôi lấy ảnh của 25 nam và 25 nữ đầu tiên làm tập training set; 25 nam và 25 nữ còn lại làm test set. Với mỗi người, tôi chỉ lấy các khuôn mặt không bị che bởi kính và khăn.</p><p><strong>Feature Extraction</strong>: vì mỗi bức ảnh có kích thước <code class=\"language-plaintext highlighter-rouge\">3x165x120</code> (số channels <code class=\"language-plaintext highlighter-rouge\">3</code>, chiều cao <code class=\"language-plaintext highlighter-rouge\">165</code>, chiều rộng <code class=\"language-plaintext highlighter-rouge\">120</code>) là một số khá lớn nên ta sẽ làm thực hiện Feature Extraction bằng hai bước đơn giản sau (<em>bạn đọc được khuyến khích đọc bài <a href=\"/general/2017/02/06/featureengineering/\">Giới thiệu về Feature Engineering</a></em>):</p><ul>\n<li>\n<p>Chuyển ảnh màu về ảnh xám theo công thức <code class=\"language-plaintext highlighter-rouge\">Y' = 0.299 R + 0.587 G + 0.114 B </code> (Xem thêm tại <a href=\"https://en.wikipedia.org/wiki/Grayscale#Luma_coding_in_video_systems\">Grayscale - wiki</a>).</p>\n</li>\n<li>\n<p><em>Kéo dài</em> ảnh xám thu được thành 1 vector hàng có số chiều <code class=\"language-plaintext highlighter-rouge\">165x120</code>, sau đó sử dụng một <em>random projection matrix</em> để giảm số chiều về <code class=\"language-plaintext highlighter-rouge\">500</code>. Bạn đọc có thể thay giá trị này bằng các số khác nhỏ hơn <code class=\"language-plaintext highlighter-rouge\">1000</code>.</p>\n</li>\n</ul><p>Chúng ta có thể bắt đầu làm việc với Python ngay bây giờ. Tôi sẽ sử dụng hàm <a href=\"http://scikit-learn.org/stable/modules/generated/sklearn.linear_model.LogisticRegression.html\">sklearn.linear_model.LogisticRegression</a> trong thư viện <code class=\"language-plaintext highlighter-rouge\">sklearn</code> cho các ví dụ trong bài này. Nếu không muốn đọc phần này, bạn có thể lấy <a href=\"/assets/LogReg2/ARGender.ipynb\">source code ở dây</a>.</p><p><strong>Chú ý:</strong> Hàm <a href=\"http://scikit-learn.org/stable/modules/generated/sklearn.linear_model.LogisticRegression.html\">sklearn.linear_model.LogisticRegression</a> nhận dữ liệu ở dạng vector hàng.</p><p><a name=\"lam-viec-voi-python\"></a></p><h3 id=\"làm-việc-với-python\">Làm việc với Python</h3><p>Khai báo thư viện</p><div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kn\">import</span> <span class=\"nn\">numpy</span> <span class=\"k\">as</span> <span class=\"n\">np</span> \n<span class=\"kn\">from</span> <span class=\"nn\">sklearn</span> <span class=\"kn\">import</span> <span class=\"n\">linear_model</span>           <span class=\"c1\"># for logistic regression\n</span><span class=\"kn\">from</span> <span class=\"nn\">sklearn.metrics</span> <span class=\"kn\">import</span> <span class=\"n\">accuracy_score</span> <span class=\"c1\"># for evaluation\n</span><span class=\"kn\">from</span> <span class=\"nn\">scipy</span> <span class=\"kn\">import</span> <span class=\"n\">misc</span>                     <span class=\"c1\"># for loading image\n</span><span class=\"n\">np</span><span class=\"p\">.</span><span class=\"n\">random</span><span class=\"p\">.</span><span class=\"n\">seed</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span>                          <span class=\"c1\"># for fixing random values\n</span></code></pre></div></div><p>Phân chia training set và test set, lựa chọn các <em>views</em>.</p><div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"n\">path</span> <span class=\"o\">=</span> <span class=\"s\">'../data/AR/'</span> <span class=\"c1\"># path to the database \n</span><span class=\"n\">train_ids</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"p\">.</span><span class=\"n\">arange</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">26</span><span class=\"p\">)</span>\n<span class=\"n\">test_ids</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"p\">.</span><span class=\"n\">arange</span><span class=\"p\">(</span><span class=\"mi\">26</span><span class=\"p\">,</span> <span class=\"mi\">50</span><span class=\"p\">)</span>\n<span class=\"n\">view_ids</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"p\">.</span><span class=\"n\">hstack</span><span class=\"p\">((</span><span class=\"n\">np</span><span class=\"p\">.</span><span class=\"n\">arange</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">8</span><span class=\"p\">),</span> <span class=\"n\">np</span><span class=\"p\">.</span><span class=\"n\">arange</span><span class=\"p\">(</span><span class=\"mi\">14</span><span class=\"p\">,</span> <span class=\"mi\">21</span><span class=\"p\">)))</span>\n</code></pre></div></div><p>Tạo <em>random projection matrix</em>.</p><div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"n\">D</span> <span class=\"o\">=</span> <span class=\"mi\">165</span><span class=\"o\">*</span><span class=\"mi\">120</span> <span class=\"c1\"># original dimension \n</span><span class=\"n\">d</span> <span class=\"o\">=</span> <span class=\"mi\">500</span> <span class=\"c1\"># new dimension \n</span>\n<span class=\"c1\"># generate the projection matrix \n</span><span class=\"n\">ProjectionMatrix</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"p\">.</span><span class=\"n\">random</span><span class=\"p\">.</span><span class=\"n\">randn</span><span class=\"p\">(</span><span class=\"n\">D</span><span class=\"p\">,</span> <span class=\"n\">d</span><span class=\"p\">)</span> \n</code></pre></div></div><p>Xây dựng danh sách các tên files.</p><div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">def</span> <span class=\"nf\">build_list_fn</span><span class=\"p\">(</span><span class=\"n\">pre</span><span class=\"p\">,</span> <span class=\"n\">img_ids</span><span class=\"p\">,</span> <span class=\"n\">view_ids</span><span class=\"p\">):</span>\n    <span class=\"s\">\"\"\"\n    INPUT:\n        pre = 'M-' or 'W-'\n        img_ids: indexes of images\n        view_ids: indexes of views\n    OUTPUT:\n        a list of filenames \n    \"\"\"</span>\n    <span class=\"n\">list_fn</span> <span class=\"o\">=</span> <span class=\"p\">[]</span>\n    <span class=\"k\">for</span> <span class=\"n\">im_id</span> <span class=\"ow\">in</span> <span class=\"n\">img_ids</span><span class=\"p\">:</span>\n        <span class=\"k\">for</span> <span class=\"n\">v_id</span> <span class=\"ow\">in</span> <span class=\"n\">view_ids</span><span class=\"p\">:</span>\n            <span class=\"n\">fn</span> <span class=\"o\">=</span> <span class=\"n\">path</span> <span class=\"o\">+</span> <span class=\"n\">pre</span> <span class=\"o\">+</span> <span class=\"nb\">str</span><span class=\"p\">(</span><span class=\"n\">im_id</span><span class=\"p\">).</span><span class=\"n\">zfill</span><span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"p\">)</span> <span class=\"o\">+</span> <span class=\"s\">'-'</span> <span class=\"o\">+</span> \\\n                <span class=\"nb\">str</span><span class=\"p\">(</span><span class=\"n\">v_id</span><span class=\"p\">).</span><span class=\"n\">zfill</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">)</span> <span class=\"o\">+</span> <span class=\"s\">'.bmp'</span>\n            <span class=\"n\">list_fn</span><span class=\"p\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"n\">fn</span><span class=\"p\">)</span>\n    <span class=\"k\">return</span> <span class=\"n\">list_fn</span> \n</code></pre></div></div><p><strong>Feature Extraction:</strong> Xây dựng dữ liệu cho training set và test set.</p><div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">def</span> <span class=\"nf\">rgb2gray</span><span class=\"p\">(</span><span class=\"n\">rgb</span><span class=\"p\">):</span>\n<span class=\"c1\">#     Y' = 0.299 R + 0.587 G + 0.114 B \n</span>    <span class=\"k\">return</span> <span class=\"n\">rgb</span><span class=\"p\">[:,:,</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">*</span><span class=\"p\">.</span><span class=\"mi\">299</span> <span class=\"o\">+</span> <span class=\"n\">rgb</span><span class=\"p\">[:,</span> <span class=\"p\">:,</span> <span class=\"mi\">1</span><span class=\"p\">]</span><span class=\"o\">*</span><span class=\"p\">.</span><span class=\"mi\">587</span> <span class=\"o\">+</span> <span class=\"n\">rgb</span><span class=\"p\">[:,</span> <span class=\"p\">:,</span> <span class=\"mi\">2</span><span class=\"p\">]</span><span class=\"o\">*</span><span class=\"p\">.</span><span class=\"mi\">114</span>\n\n<span class=\"c1\"># feature extraction \n</span><span class=\"k\">def</span> <span class=\"nf\">vectorize_img</span><span class=\"p\">(</span><span class=\"n\">filename</span><span class=\"p\">):</span>    \n    <span class=\"c1\"># load image \n</span>    <span class=\"n\">rgb</span> <span class=\"o\">=</span> <span class=\"n\">misc</span><span class=\"p\">.</span><span class=\"n\">imread</span><span class=\"p\">(</span><span class=\"n\">filename</span><span class=\"p\">)</span>\n    <span class=\"c1\"># convert to gray scale \n</span>    <span class=\"n\">gray</span> <span class=\"o\">=</span> <span class=\"n\">rgb2gray</span><span class=\"p\">(</span><span class=\"n\">rgb</span><span class=\"p\">)</span>\n    <span class=\"c1\"># vectorization each row is a data point \n</span>    <span class=\"n\">im_vec</span> <span class=\"o\">=</span> <span class=\"n\">gray</span><span class=\"p\">.</span><span class=\"n\">reshape</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">D</span><span class=\"p\">)</span>\n    <span class=\"k\">return</span> <span class=\"n\">im_vec</span> \n\n<span class=\"k\">def</span> <span class=\"nf\">build_data_matrix</span><span class=\"p\">(</span><span class=\"n\">img_ids</span><span class=\"p\">,</span> <span class=\"n\">view_ids</span><span class=\"p\">):</span>\n    <span class=\"n\">total_imgs</span> <span class=\"o\">=</span> <span class=\"n\">img_ids</span><span class=\"p\">.</span><span class=\"n\">shape</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">*</span><span class=\"n\">view_ids</span><span class=\"p\">.</span><span class=\"n\">shape</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">*</span><span class=\"mi\">2</span> \n        \n    <span class=\"n\">X_full</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"p\">.</span><span class=\"n\">zeros</span><span class=\"p\">((</span><span class=\"n\">total_imgs</span><span class=\"p\">,</span> <span class=\"n\">D</span><span class=\"p\">))</span>\n    <span class=\"n\">y</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"p\">.</span><span class=\"n\">hstack</span><span class=\"p\">((</span><span class=\"n\">np</span><span class=\"p\">.</span><span class=\"n\">zeros</span><span class=\"p\">((</span><span class=\"n\">total_imgs</span><span class=\"o\">/</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"p\">)),</span> <span class=\"n\">np</span><span class=\"p\">.</span><span class=\"n\">ones</span><span class=\"p\">((</span><span class=\"n\">total_imgs</span><span class=\"o\">/</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"p\">))))</span>\n    \n    <span class=\"n\">list_fn_m</span> <span class=\"o\">=</span> <span class=\"n\">build_list_fn</span><span class=\"p\">(</span><span class=\"s\">'M-'</span><span class=\"p\">,</span> <span class=\"n\">img_ids</span><span class=\"p\">,</span> <span class=\"n\">view_ids</span><span class=\"p\">)</span>\n    <span class=\"n\">list_fn_w</span> <span class=\"o\">=</span> <span class=\"n\">build_list_fn</span><span class=\"p\">(</span><span class=\"s\">'W-'</span><span class=\"p\">,</span> <span class=\"n\">img_ids</span><span class=\"p\">,</span> <span class=\"n\">view_ids</span><span class=\"p\">)</span>\n    <span class=\"n\">list_fn</span> <span class=\"o\">=</span> <span class=\"n\">list_fn_m</span> <span class=\"o\">+</span> <span class=\"n\">list_fn_w</span> \n    \n    <span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">list_fn</span><span class=\"p\">)):</span>\n        <span class=\"n\">X_full</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">,</span> <span class=\"p\">:]</span> <span class=\"o\">=</span> <span class=\"n\">vectorize_img</span><span class=\"p\">(</span><span class=\"n\">list_fn</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">])</span>\n\n    <span class=\"n\">X</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"p\">.</span><span class=\"n\">dot</span><span class=\"p\">(</span><span class=\"n\">X_full</span><span class=\"p\">,</span> <span class=\"n\">ProjectionMatrix</span><span class=\"p\">)</span>\n    <span class=\"k\">return</span> <span class=\"p\">(</span><span class=\"n\">X</span><span class=\"p\">,</span> <span class=\"n\">y</span><span class=\"p\">)</span>\n\n<span class=\"p\">(</span><span class=\"n\">X_train_full</span><span class=\"p\">,</span> <span class=\"n\">y_train</span><span class=\"p\">)</span> <span class=\"o\">=</span> <span class=\"n\">build_data_matrix</span><span class=\"p\">(</span><span class=\"n\">train_ids</span><span class=\"p\">,</span> <span class=\"n\">view_ids</span><span class=\"p\">)</span>\n<span class=\"n\">x_mean</span> <span class=\"o\">=</span> <span class=\"n\">X_train_full</span><span class=\"p\">.</span><span class=\"n\">mean</span><span class=\"p\">(</span><span class=\"n\">axis</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">)</span>\n<span class=\"n\">x_var</span>  <span class=\"o\">=</span> <span class=\"n\">X_train_full</span><span class=\"p\">.</span><span class=\"n\">var</span><span class=\"p\">(</span><span class=\"n\">axis</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">)</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">feature_extraction</span><span class=\"p\">(</span><span class=\"n\">X</span><span class=\"p\">):</span>\n    <span class=\"k\">return</span> <span class=\"p\">(</span><span class=\"n\">X</span> <span class=\"o\">-</span> <span class=\"n\">x_mean</span><span class=\"p\">)</span><span class=\"o\">/</span><span class=\"n\">x_var</span>     \n\n<span class=\"n\">X_train</span> <span class=\"o\">=</span> <span class=\"n\">feature_extraction</span><span class=\"p\">(</span><span class=\"n\">X_train_full</span><span class=\"p\">)</span>\n<span class=\"n\">X_train_full</span> <span class=\"o\">=</span> <span class=\"bp\">None</span> <span class=\"c1\">## free this variable \n</span>\n<span class=\"p\">(</span><span class=\"n\">X_test_full</span><span class=\"p\">,</span> <span class=\"n\">y_test</span><span class=\"p\">)</span> <span class=\"o\">=</span> <span class=\"n\">build_data_matrix</span><span class=\"p\">(</span><span class=\"n\">test_ids</span><span class=\"p\">,</span> <span class=\"n\">view_ids</span><span class=\"p\">)</span>\n<span class=\"n\">X_test</span> <span class=\"o\">=</span> <span class=\"n\">feature_extraction</span><span class=\"p\">(</span><span class=\"n\">X_test_full</span><span class=\"p\">)</span>\n<span class=\"n\">X_test_full</span> <span class=\"o\">=</span> <span class=\"bp\">None</span> \n</code></pre></div></div><p><strong>Chú ý:</strong> Trong đoạn code trên tôi có sử dụng phương pháp chuẩn hóa dữ liệu <a href=\"/general/2017/02/06/featureengineering/#standardization\">Standardization</a>. Trong đó <code class=\"language-plaintext highlighter-rouge\">x_mean</code> và <code class=\"language-plaintext highlighter-rouge\">x_var</code> lần lượt là vector kỳ vọng và phương sai của toàn bộ dữ liệu training. <code class=\"language-plaintext highlighter-rouge\">X_train_full</code>, <code class=\"language-plaintext highlighter-rouge\">X_test_full</code> là các ma trận dữ liệu đã được giảm số chiều nhưng chưa được chuẩn hóa. Hàm <code class=\"language-plaintext highlighter-rouge\">feature_extraction</code> giúp chuẩn hóa dữ liệu dựa vào <code class=\"language-plaintext highlighter-rouge\">x_mean</code> và <code class=\"language-plaintext highlighter-rouge\">x_var</code> của <code class=\"language-plaintext highlighter-rouge\">X_train_full</code>.</p><p>Đoạn code dưới đây thực hiện thuật toán Logistic Regression, dự đoán output của test data và đánh giá kết quả. Một chú ý nhỏ, hàm Logistic Regression trong thư viện sklearn có nhiều biến thể khác nhau. Để sử dụng thuật toán Logistic Regression <em>thuần</em> mà tôi đã giới thiệu trong bài <a href=\"/2017/01/27/logisticregression/\">Logistic Regression</a>, chúng ta cần đặt giá trị cho <code class=\"language-plaintext highlighter-rouge\">C</code> là một số lớn (để nghịch đảo của nó gần với 0. Tạm thời các bạn chưa cần quan tâm tới điều này, chỉ cần chọn <code class=\"language-plaintext highlighter-rouge\">C</code> lớn là được).</p><div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"n\">logreg</span> <span class=\"o\">=</span> <span class=\"n\">linear_model</span><span class=\"p\">.</span><span class=\"n\">LogisticRegression</span><span class=\"p\">(</span><span class=\"n\">C</span><span class=\"o\">=</span><span class=\"mf\">1e5</span><span class=\"p\">)</span> <span class=\"c1\"># just a big number \n</span><span class=\"n\">logreg</span><span class=\"p\">.</span><span class=\"n\">fit</span><span class=\"p\">(</span><span class=\"n\">X_train</span><span class=\"p\">,</span> <span class=\"n\">y_train</span><span class=\"p\">)</span>\n\n<span class=\"n\">y_pred</span> <span class=\"o\">=</span> <span class=\"n\">logreg</span><span class=\"p\">.</span><span class=\"n\">predict</span><span class=\"p\">(</span><span class=\"n\">X_test</span><span class=\"p\">)</span>\n<span class=\"k\">print</span> <span class=\"s\">\"Accuracy: %.2f %%\"</span> <span class=\"o\">%</span><span class=\"p\">(</span><span class=\"mi\">100</span><span class=\"o\">*</span><span class=\"n\">accuracy_score</span><span class=\"p\">(</span><span class=\"n\">y_test</span><span class=\"p\">,</span> <span class=\"n\">y_pred</span><span class=\"p\">))</span>\n</code></pre></div></div><div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Accuracy: 90.33 %\n</code></pre></div></div><p>90.33%, tức là cứ 10 bức ảnh trong test set thì có trung bình hơn 9 bức được nhận dạng đúng. Không tệ, nhất là khi chúng ta vẫn chưa phải làm gì nhiều!</p><p>Để xác định <em>nhãn</em> của một ảnh, đầu ra của hàm <a href=\"/2017/01/27/logisticregression/#sigmoid-function\">sigmoid</a> được so sánh với 0.5. Nếu giá trị đó lớn hơn 0.5, ta kết luận đó là ảnh của nam, ngược lại, đó là ảnh của nữ. Để xem giá trị sau hàm sigmoid (tức xác suất để ảnh đó là nam), chúng ta sử dụng hàm <code class=\"language-plaintext highlighter-rouge\">predict_proba</code> như sau:</p><div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">def</span> <span class=\"nf\">feature_extraction_fn</span><span class=\"p\">(</span><span class=\"n\">fn</span><span class=\"p\">):</span>\n    <span class=\"s\">\"\"\"\n    extract feature from filename\n    \"\"\"</span>\n    <span class=\"c1\"># vectorize\n</span>    <span class=\"n\">im</span> <span class=\"o\">=</span> <span class=\"n\">vectorize_img</span><span class=\"p\">(</span><span class=\"n\">fn</span><span class=\"p\">)</span>\n    <span class=\"c1\"># project\n</span>    <span class=\"n\">im1</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"p\">.</span><span class=\"n\">dot</span><span class=\"p\">(</span><span class=\"n\">im</span><span class=\"p\">,</span> <span class=\"n\">ProjectionMatrix</span><span class=\"p\">)</span>\n    <span class=\"c1\"># standardization \n</span>    <span class=\"k\">return</span> <span class=\"n\">feature_extraction</span><span class=\"p\">(</span><span class=\"n\">im1</span><span class=\"p\">)</span>\n\n<span class=\"n\">fn1</span> <span class=\"o\">=</span> <span class=\"n\">path</span> <span class=\"o\">+</span> <span class=\"s\">'M-036-18.bmp'</span>\n<span class=\"n\">fn2</span> <span class=\"o\">=</span> <span class=\"n\">path</span> <span class=\"o\">+</span> <span class=\"s\">'W-045-01.bmp'</span>\n<span class=\"n\">fn3</span> <span class=\"o\">=</span> <span class=\"n\">path</span> <span class=\"o\">+</span> <span class=\"s\">'M-048-01.bmp'</span>\n<span class=\"n\">fn4</span> <span class=\"o\">=</span> <span class=\"n\">path</span> <span class=\"o\">+</span> <span class=\"s\">'W-027-02.bmp'</span>\n\n<span class=\"n\">x1</span> <span class=\"o\">=</span> <span class=\"n\">feature_extraction_fn</span><span class=\"p\">(</span><span class=\"n\">fn1</span><span class=\"p\">)</span>\n<span class=\"n\">p1</span> <span class=\"o\">=</span> <span class=\"n\">logreg</span><span class=\"p\">.</span><span class=\"n\">predict_proba</span><span class=\"p\">(</span><span class=\"n\">x1</span><span class=\"p\">)</span>\n<span class=\"k\">print</span><span class=\"p\">(</span><span class=\"n\">p1</span><span class=\"p\">)</span>\n\n<span class=\"n\">x2</span> <span class=\"o\">=</span> <span class=\"n\">feature_extraction_fn</span><span class=\"p\">(</span><span class=\"n\">fn2</span><span class=\"p\">)</span>\n<span class=\"n\">p2</span> <span class=\"o\">=</span> <span class=\"n\">logreg</span><span class=\"p\">.</span><span class=\"n\">predict_proba</span><span class=\"p\">(</span><span class=\"n\">x2</span><span class=\"p\">)</span>\n<span class=\"k\">print</span><span class=\"p\">(</span><span class=\"n\">p2</span><span class=\"p\">)</span>\n\n<span class=\"n\">x3</span> <span class=\"o\">=</span> <span class=\"n\">feature_extraction_fn</span><span class=\"p\">(</span><span class=\"n\">fn3</span><span class=\"p\">)</span>\n<span class=\"n\">p3</span> <span class=\"o\">=</span> <span class=\"n\">logreg</span><span class=\"p\">.</span><span class=\"n\">predict_proba</span><span class=\"p\">(</span><span class=\"n\">x3</span><span class=\"p\">)</span>\n<span class=\"k\">print</span><span class=\"p\">(</span><span class=\"n\">p3</span><span class=\"p\">)</span>\n\n<span class=\"n\">x4</span> <span class=\"o\">=</span> <span class=\"n\">feature_extraction_fn</span><span class=\"p\">(</span><span class=\"n\">fn4</span><span class=\"p\">)</span>\n<span class=\"n\">p4</span> <span class=\"o\">=</span> <span class=\"n\">logreg</span><span class=\"p\">.</span><span class=\"n\">predict_proba</span><span class=\"p\">(</span><span class=\"n\">x4</span><span class=\"p\">)</span>\n<span class=\"k\">print</span><span class=\"p\">(</span><span class=\"n\">p4</span><span class=\"p\">)</span>\n</code></pre></div></div><div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>[[ 0.87940218  0.12059782]]\n[[ 0.0172217  0.9827783]]\n[[ 0.30458761  0.69541239]]\n[[ 0.83989242  0.16010758]]\n</code></pre></div></div><p>Kết quả thu được là xác suất để bức ảnh đó là ảnh của nam (cột thứ nhất) và của nữ (cột thứ hai). Dưới đây là hình minh họa:</p><div class=\"imgcap\">\n<img align=\"center\" src=\"\\assets\\LogReg2\\ARgenderResult.png\" width=\"800\"/>\n<div class=\"thecap\">Hình 2: Ví dụ về kết quả tìm được bằng Logistic Regression</div>\n</div><p>Hàng trên gồm các hình được phân loại đúng, hàng dưới gồm các hình bị phân loại sai. Có một vài nhận xét về hàng dưới. Từ hai bức ảnh hàng dưới, chúng ta có thể đoán rằng Logistic Regression quan tâm đến tóc phía sau gáy nhiều hơn là râu! Việc thuật toán dựa trên những đặc trưng nào của mỗi class phụ thuộc rất nhiều vào training data. Nếu trong training data, hầu hết nam không có râu và hầu hết nữ có tóc dài thì kết quả này là có thể lý giải được.</p><p><strong>Trong Machine Learning, thuật toán là quan trọng, nhưng thuật toán tốt mà dữ liệu không tốt thì sẽ dẫn đến những tác dụng ngược!</strong></p><p>(Source code cho ví dụ này có thể tìm thấy <a href=\"https://github.com/tiepvupsu/tiepvupsu.github.io/blob/master/assets/LogReg2/ARGender.ipynb\">ở dây</a>.)\n<a name=\"-bai-toan-phan-biet-hai-chu-so-viet-tay\"></a></p>"}, "formulas": {"title": "<h2 id=\"2-bài-toán-phân-biệt-hai-chữ-số-viết-tay\">2. Bài toán phân biệt hai chữ số viết tay</h2>", "content": "<p>Chúng ta cùng sang ví dụ thứ hai về phân biệt hai chữ số trong <a href=\"/2017/01/04/kmeans2/#bo-co-so-du-lieu-mnist\">bộ cơ sở dữ liệu MNIST</a>. Cụ thể, tôi sẽ làm việc với hai chữ số 0 và 1. Bạn đọc hoàn toàn có thể thử với các chữ số khác bằng cách thay đổi một dòng lệnh. Khác với AR Face, bộ dữ liệu này có thể dễ dàng được download về từ <a href=\"http://yann.lecun.com/exdb/mnist/\">trang chủ</a> của nó.</p><p>Chúng ta có thể bắt tay vào làm luôn.</p><p>Khai báo thư viện:</p><div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\"># %reset\n</span><span class=\"kn\">import</span> <span class=\"nn\">numpy</span> <span class=\"k\">as</span> <span class=\"n\">np</span> \n<span class=\"kn\">from</span> <span class=\"nn\">mnist</span> <span class=\"kn\">import</span> <span class=\"n\">MNIST</span>\n<span class=\"kn\">import</span> <span class=\"nn\">matplotlib.pyplot</span> <span class=\"k\">as</span> <span class=\"n\">plt</span>\n<span class=\"kn\">from</span> <span class=\"nn\">sklearn</span> <span class=\"kn\">import</span> <span class=\"n\">linear_model</span>\n<span class=\"kn\">from</span> <span class=\"nn\">sklearn.metrics</span> <span class=\"kn\">import</span> <span class=\"n\">accuracy_score</span>\n<span class=\"kn\">from</span> <span class=\"nn\">display_network</span> <span class=\"kn\">import</span> <span class=\"o\">*</span>\n</code></pre></div></div><p>Load toàn bộ dữ liệu:</p><div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"n\">mntrain</span> <span class=\"o\">=</span> <span class=\"n\">MNIST</span><span class=\"p\">(</span><span class=\"s\">'../MNIST/'</span><span class=\"p\">)</span>\n<span class=\"n\">mntrain</span><span class=\"p\">.</span><span class=\"n\">load_training</span><span class=\"p\">()</span>\n<span class=\"n\">Xtrain_all</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"p\">.</span><span class=\"n\">asarray</span><span class=\"p\">(</span><span class=\"n\">mntrain</span><span class=\"p\">.</span><span class=\"n\">train_images</span><span class=\"p\">)</span>\n<span class=\"n\">ytrain_all</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"p\">.</span><span class=\"n\">array</span><span class=\"p\">(</span><span class=\"n\">mntrain</span><span class=\"p\">.</span><span class=\"n\">train_labels</span><span class=\"p\">.</span><span class=\"n\">tolist</span><span class=\"p\">())</span>\n\n<span class=\"n\">mntest</span> <span class=\"o\">=</span> <span class=\"n\">MNIST</span><span class=\"p\">(</span><span class=\"s\">'../MNIST/'</span><span class=\"p\">)</span>\n<span class=\"n\">mntest</span><span class=\"p\">.</span><span class=\"n\">load_testing</span><span class=\"p\">()</span>\n<span class=\"n\">Xtest_all</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"p\">.</span><span class=\"n\">asarray</span><span class=\"p\">(</span><span class=\"n\">mntest</span><span class=\"p\">.</span><span class=\"n\">test_images</span><span class=\"p\">)</span>\n<span class=\"n\">ytest_all</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"p\">.</span><span class=\"n\">array</span><span class=\"p\">(</span><span class=\"n\">mntest</span><span class=\"p\">.</span><span class=\"n\">test_labels</span><span class=\"p\">.</span><span class=\"n\">tolist</span><span class=\"p\">())</span>\n</code></pre></div></div><p>Sau bưóc này, toàn bộ dữ liệu training data và test data được lưu ở hai ma trận <code class=\"language-plaintext highlighter-rouge\">X_train_all</code> và <code class=\"language-plaintext highlighter-rouge\">X_test_all</code>, mỗi hàng của các ma trận này chứa một điểm dữ liệu, tức một bức ảnh đã được <em>vector hóa</em>.</p><p>Để lấy các hàng tương ứng với chữ số 0 và chữ số 1, ta khai báo biến sau:</p><div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"n\">cls</span> <span class=\"o\">=</span> <span class=\"p\">[[</span><span class=\"mi\">0</span><span class=\"p\">],</span> <span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]]</span>\n</code></pre></div></div><p>Nếu bạn muốn thử với cặp <code class=\"language-plaintext highlighter-rouge\">3</code> và <code class=\"language-plaintext highlighter-rouge\">4</code>, chỉ cần thay dòng này bằng <code class=\"language-plaintext highlighter-rouge\">cls = [[3], [4]]</code>. Nếu bạn muốn phân loại <code class=\"language-plaintext highlighter-rouge\">(4, 7)</code> và <code class=\"language-plaintext highlighter-rouge\">(5, 6)</code>, chỉ cần thay dòng này bằng <code class=\"language-plaintext highlighter-rouge\">cls = [[4, 7], [5, 6]]</code>. Các cặp bất kỳ khác đều có thể thực hiện bằng cách thay chỉ một dòng này.</p><p>Đoạn code dưới đây thực hiện việc <em>extract</em> toàn bộ dữ liệu cho các chữ số <code class=\"language-plaintext highlighter-rouge\">0</code> và <code class=\"language-plaintext highlighter-rouge\">1</code> trong tập training data và test data.</p><div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">def</span> <span class=\"nf\">extract_data</span><span class=\"p\">(</span><span class=\"n\">X</span><span class=\"p\">,</span> <span class=\"n\">y</span><span class=\"p\">,</span> <span class=\"n\">classes</span><span class=\"p\">):</span>\n    <span class=\"s\">\"\"\"\n    X: numpy array, matrix of size (N, d), d is data dim\n    y: numpy array, size (N, )\n    cls: two lists of labels. For example: \n        cls = [[1, 4, 7], [5, 6, 8]]\n    return:\n        X: extracted data\n        y: extracted label \n            (0 and 1, corresponding to two lists in cls)\n    \"\"\"</span>\n    <span class=\"n\">y_res_id</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"p\">.</span><span class=\"n\">array</span><span class=\"p\">([])</span>\n    <span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"n\">cls</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]:</span>\n        <span class=\"n\">y_res_id</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"p\">.</span><span class=\"n\">hstack</span><span class=\"p\">((</span><span class=\"n\">y_res_id</span><span class=\"p\">,</span> <span class=\"n\">np</span><span class=\"p\">.</span><span class=\"n\">where</span><span class=\"p\">(</span><span class=\"n\">y</span> <span class=\"o\">==</span> <span class=\"n\">i</span><span class=\"p\">)[</span><span class=\"mi\">0</span><span class=\"p\">]))</span>\n    <span class=\"n\">n0</span> <span class=\"o\">=</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">y_res_id</span><span class=\"p\">)</span>\n\n    <span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"n\">cls</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]:</span>\n        <span class=\"n\">y_res_id</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"p\">.</span><span class=\"n\">hstack</span><span class=\"p\">((</span><span class=\"n\">y_res_id</span><span class=\"p\">,</span> <span class=\"n\">np</span><span class=\"p\">.</span><span class=\"n\">where</span><span class=\"p\">(</span><span class=\"n\">y</span> <span class=\"o\">==</span> <span class=\"n\">i</span><span class=\"p\">)[</span><span class=\"mi\">0</span><span class=\"p\">]))</span>\n    <span class=\"n\">n1</span> <span class=\"o\">=</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">y_res_id</span><span class=\"p\">)</span> <span class=\"o\">-</span> <span class=\"n\">n0</span> \n\n    <span class=\"n\">y_res_id</span> <span class=\"o\">=</span> <span class=\"n\">y_res_id</span><span class=\"p\">.</span><span class=\"n\">astype</span><span class=\"p\">(</span><span class=\"nb\">int</span><span class=\"p\">)</span>\n    <span class=\"n\">X_res</span> <span class=\"o\">=</span> <span class=\"n\">X</span><span class=\"p\">[</span><span class=\"n\">y_res_id</span><span class=\"p\">,</span> <span class=\"p\">:]</span><span class=\"o\">/</span><span class=\"mf\">255.0</span>\n    <span class=\"n\">y_res</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"p\">.</span><span class=\"n\">asarray</span><span class=\"p\">([</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">*</span><span class=\"n\">n0</span> <span class=\"o\">+</span> <span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span><span class=\"o\">*</span><span class=\"n\">n1</span><span class=\"p\">)</span>\n    <span class=\"k\">return</span> <span class=\"p\">(</span><span class=\"n\">X_res</span><span class=\"p\">,</span> <span class=\"n\">y_res</span><span class=\"p\">)</span>\n\n\n<span class=\"c1\"># extract data for training \n</span><span class=\"p\">(</span><span class=\"n\">X_train</span><span class=\"p\">,</span> <span class=\"n\">y_train</span><span class=\"p\">)</span> <span class=\"o\">=</span> <span class=\"n\">extract_data</span><span class=\"p\">(</span><span class=\"n\">Xtrain_all</span><span class=\"p\">,</span> <span class=\"n\">ytrain_all</span><span class=\"p\">,</span> <span class=\"n\">cls</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># extract data for test \n</span><span class=\"p\">(</span><span class=\"n\">X_test</span><span class=\"p\">,</span> <span class=\"n\">y_test</span><span class=\"p\">)</span> <span class=\"o\">=</span> <span class=\"n\">extract_data</span><span class=\"p\">(</span><span class=\"n\">Xtest_all</span><span class=\"p\">,</span> <span class=\"n\">ytest_all</span><span class=\"p\">,</span> <span class=\"n\">cls</span><span class=\"p\">)</span>\n</code></pre></div></div><p>Vì mỗi điểm dữ liệu có số phần tử là 784 (28x28), là một số khá nhỏ, nên ta không cần thêm bước giảm số chiều dữ liệu nữa. Tuy nhiên, tôi có thực hiện thêm một bước chuẩn hóa để đưa dữ liệu về đoạn <code class=\"language-plaintext highlighter-rouge\">[0, 1]</code> bằng cách chia toàn bộ hai ma trận dữ liệu cho <code class=\"language-plaintext highlighter-rouge\">255.0</code>.</p><p>Tới đây ta có thể <em>train</em> mô hình Logistic Regression và đánh giá mô hình này.</p><div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\"># train the logistic regression model \n</span><span class=\"n\">logreg</span> <span class=\"o\">=</span> <span class=\"n\">linear_model</span><span class=\"p\">.</span><span class=\"n\">LogisticRegression</span><span class=\"p\">(</span><span class=\"n\">C</span><span class=\"o\">=</span><span class=\"mf\">1e5</span><span class=\"p\">)</span> <span class=\"c1\"># just a big number \n</span><span class=\"n\">logreg</span><span class=\"p\">.</span><span class=\"n\">fit</span><span class=\"p\">(</span><span class=\"n\">X_train</span><span class=\"p\">,</span> <span class=\"n\">y_train</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># predict \n</span><span class=\"n\">y_pred</span> <span class=\"o\">=</span> <span class=\"n\">logreg</span><span class=\"p\">.</span><span class=\"n\">predict</span><span class=\"p\">(</span><span class=\"n\">X_test</span><span class=\"p\">)</span>\n<span class=\"k\">print</span> <span class=\"s\">\"Accuracy: %.2f %%\"</span> <span class=\"o\">%</span><span class=\"p\">(</span><span class=\"mi\">100</span><span class=\"o\">*</span><span class=\"n\">accuracy_score</span><span class=\"p\">(</span><span class=\"n\">y_test</span><span class=\"p\">,</span> <span class=\"n\">y_pred</span><span class=\"p\">.</span><span class=\"n\">tolist</span><span class=\"p\">()))</span>\n</code></pre></div></div><div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Accuracy: 99.95 %\n</code></pre></div></div><p>Tuyệt vời, gần như 100% được phân loại chính xác. Điều này là dễ hiểu vì hai chữ số 0 và 1 khác nhau quá nhiều. Bộ cơ sở dữ liệu này với toàn bộ 10 classes hiện nay đã được phân loại với độ chính xác trên 99.7%.</p><p>Chúng ta cùng đi tìm những ảnh bị phân loại sai:</p><div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\"># display misclassified image(s)\n</span><span class=\"n\">mis</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"p\">.</span><span class=\"n\">where</span><span class=\"p\">((</span><span class=\"n\">y_pred</span> <span class=\"o\">-</span> <span class=\"n\">y_test</span><span class=\"p\">)</span> <span class=\"o\">!=</span> <span class=\"mi\">0</span><span class=\"p\">)[</span><span class=\"mi\">0</span><span class=\"p\">]</span>\n<span class=\"n\">Xmis</span> <span class=\"o\">=</span> <span class=\"n\">X_test</span><span class=\"p\">[</span><span class=\"n\">mis</span><span class=\"p\">,</span> <span class=\"p\">:]</span>\n\n<span class=\"n\">plt</span><span class=\"p\">.</span><span class=\"n\">axis</span><span class=\"p\">(</span><span class=\"s\">'off'</span><span class=\"p\">)</span>\n<span class=\"n\">A</span> <span class=\"o\">=</span> <span class=\"n\">display_network</span><span class=\"p\">(</span><span class=\"n\">Xmis</span><span class=\"p\">.</span><span class=\"n\">T</span><span class=\"p\">)</span>\n<span class=\"n\">f2</span> <span class=\"o\">=</span> <span class=\"n\">plt</span><span class=\"p\">.</span><span class=\"n\">imshow</span><span class=\"p\">(</span><span class=\"n\">A</span><span class=\"p\">,</span> <span class=\"n\">interpolation</span><span class=\"o\">=</span><span class=\"s\">'nearest'</span> <span class=\"p\">)</span>\n<span class=\"n\">plt</span><span class=\"p\">.</span><span class=\"n\">gray</span><span class=\"p\">()</span>\n<span class=\"n\">plt</span><span class=\"p\">.</span><span class=\"n\">show</span><span class=\"p\">()</span>\n</code></pre></div></div><div class=\"imgcap\">\n<img align=\"center\" src=\"\\assets\\LogReg2\\0.png\" width=\"100\"/>\n<div class=\"thecap\">Hình 3: Chữ số bị phân loại sai trong bài toán phân loại ảnh chữ số 0 và 1</div>\n</div><p>Như vậy là chỉ có một ảnh bị phân loại sai. Ảnh này là chữ số 0 nhưng bị misclassified thành chữ số 1, có thể vì nét đậm nhất của nó rất giống với chữ số 1.</p><p>Source code cho ví dụ này có thể được tìm thấy <a href=\"/assets/LogReg2/LogReg2.ipynb\">ở đây</a>.</p><p><a name=\"-binary-classifiers-cho-multi-class-classification-problems\"></a></p>"}, "examples": {"title": "<h2 id=\"3-binary-classifiers-cho-multi-class-classification-problems\">3. Binary Classifiers cho Multi-class Classification problems</h2>", "content": "<p>Có lẽ nhiều bạn đang đặt câu hỏi: Các ví dụ trên đây đều làm với bài toán có hai classes. Vậy nếu có nhiều hơn hai classes, ví dụ như 10 classes của MNIST, thì làm thế nào?</p><p>Có nhiều thuật toán khác được xây dựng riêng cho các bài toán với nhiều classes (multi-class classification problems), tôi sẽ giới thiệu sau. Còn bây giờ, chúng ta vẫn có thể sử dụng các <em>binary classifiers</em> để thực hiện công việc này, với một chút thay đổi. \n<!-- Để tiện cho việc diễn giải, tôi sử dụng MNIST làm ví dụ. Các cơ sở dữ liệu khác được suy ra một cách tương tự. --></p><p>Có <em>ít nhất</em> bốn cách để áp dụng <em>binary classifiers</em> vào các bài toán multi-class classification:</p><p><a name=\"one-vs-one\"></a></p><h3 id=\"one-vs-one\">One-vs-one</h3><p>Xây dựng rất nhiều bộ binary classifiers cho từng cặp classes. Bộ thứ nhất phân biệt class 1 và class 2, bộ thứ hai phân biệt class 1 và class 3, … Khi có một dữ liệu mới vào, đưa nó vào toàn bộ các bộ binary classifiers trên. Kết quả cuối cùng có thể được xác định bằng cách xem class nào mà điểm dữ liệu đó được phân vào nhiều nhất (major voting). Hoặc với Logistic Regression thì ta có thể tính <em>tổng các xác suất</em> tìm được sau mỗi bộ binary classifier.</p><p>Như vậy, nếu có \\(C\\) classes thì tổng số binary classifiers phải dùng là \\(\\frac{n(n-1)}{2}\\). Đây là một con số lớn, cách làm này không lợi về tính toán. Hơn nữa, nếu một chữ số thực ra là chữ số <code class=\"language-plaintext highlighter-rouge\">1</code>, nhưng lại được đưa vào bộ phân lớp giữa các chữ số <code class=\"language-plaintext highlighter-rouge\">5</code> và <code class=\"language-plaintext highlighter-rouge\">6</code>, thì cả hai khả năng tìm được (là <code class=\"language-plaintext highlighter-rouge\">5</code> hoặc <code class=\"language-plaintext highlighter-rouge\">6</code>) đều không hợp lý!</p><p><a name=\"hierarchical-phan-tang\"></a></p><h3 id=\"hierarchical-phân-tầng\">Hierarchical (phân tầng)</h3><p>Các làm như <strong>one-vs-one</strong> sẽ mất rất nhiều thời gian training vì có quá nhiều bộ phân lớp cần được xây dựng. Một cách khác giúp <em>tiết kiệm</em> số binary classifiers hơn đó là <strong>hierarchical</strong>. Ý tưởng như sau:</p><p>Ví dụ với MNIST với 4 chữ số <code class=\"language-plaintext highlighter-rouge\">4, 5, 6, 7</code>. Vì ta thấy chữ số <code class=\"language-plaintext highlighter-rouge\">4</code> và <code class=\"language-plaintext highlighter-rouge\">7</code> khá giống nhau, chữ số <code class=\"language-plaintext highlighter-rouge\">5</code> và <code class=\"language-plaintext highlighter-rouge\">6</code> khá giống nhau nên trước tiên chúng ta xây dựng bộ phân lớp <code class=\"language-plaintext highlighter-rouge\">[4, 7] vs [5, 6]</code>. Sau đó xây dựng thêm hai bộ <code class=\"language-plaintext highlighter-rouge\">4 vs  7</code> và <code class=\"language-plaintext highlighter-rouge\">5 vs 6</code> nữa. Tổng cộng, ta cần 3 bộ binary classifiers. Chú ý rằng có nhiều cách chia khác nhau, ví dụ <code class=\"language-plaintext highlighter-rouge\">[4, 5, 6] vs 7</code>, <code class=\"language-plaintext highlighter-rouge\">[4, 5] vs 6</code>, rồi <code class=\"language-plaintext highlighter-rouge\">4 vs 5</code>.</p><p>Ưu điểm của phương pháp này là sử dụng ít bộ binary classifiers hơn <strong>one-vs-one</strong>. \nHạn chế lớn nhất của nó là việc nếu chỉ một binary classifier cho kết quả sai thì kết quả cuối cùng chắc chắn sẽ sai. Ví dụ, nếu 1 ảnh chứa chữ số <code class=\"language-plaintext highlighter-rouge\">5</code>, nhưng ngay bước đầu tiên đã bị misclassifed sang nhánh <code class=\"language-plaintext highlighter-rouge\">[4, 7]</code> thì kết quả cuối cùng sẽ là <code class=\"language-plaintext highlighter-rouge\">4</code> hoặc <code class=\"language-plaintext highlighter-rouge\">7</code>, cả hai đều sai.</p><p><a name=\"binary-coding\"></a></p><h3 id=\"binary-coding\">Binary coding</h3><p>Có một cách giảm số binary classifiers hơn nữa là <strong>binary coding</strong>, tức <em>mã hóa</em> output của mỗi class bằng một số nhị phân. Ví dụ, nếu có 4 classes thì class thứ nhất được mã hóa là <code class=\"language-plaintext highlighter-rouge\">00</code>, ba class kia được mã hóa lần lượt là <code class=\"language-plaintext highlighter-rouge\">01, 10</code> và <code class=\"language-plaintext highlighter-rouge\">11</code>. Với cách làm này, số bộ binary classifiers phải thực hiện chỉ là \\(m = \\left\\lceil\\log_2(C)\\right\\rceil\\) trong đó \\(C\\) là số lượng class, \\(\\left\\lceil a \\right\\rceil\\) là <em>số nguyên nhỏ nhất không nhỏ hơn</em> \\(a\\). Class thứ nhất sẽ đi tìm bit đầu tiên của output (đã được mã hóa nhị phân), class thứ hai sẽ đi tìm bit thứ hai, …</p><p>Cách làm này sử dụng một số lượng nhỏ nhất các bộ <em>binary classifiers</em>. Nhưng nó có một hạn chế rất lớn là chỉ cần một bit bị phân loại sai sẽ dẫn đến dữ liệu bị phân loại sai. Hơn nữa, nếu số classes không phải là lũy thừa của hai, mã nhị phân nhận được có thể là một giá trị không tương ứng với class nào!</p><p><a name=\"one-vs-rest-hay-one-hot-coding\"></a></p><h3 id=\"one-vs-rest-hay-one-hot-coding\">one-vs-rest hay one-hot coding</h3><p>Phương pháp được sử dụng nhiều nhất là <strong>one-vs-rest</strong> (một số tài liệu gọi là <strong>ove-vs-all</strong>, <strong>one-against-rest</strong>, hoặc <strong>one-against-all</strong>) . Cụ thể, nếu có \\(C\\) classes thì ta sẽ xây dựng \\(C\\) classifiers, mỗi classifier tương ứng với một class. Classifier thứ nhất giúp phân biệt <code class=\"language-plaintext highlighter-rouge\">class 1</code> vs <code class=\"language-plaintext highlighter-rouge\">not class 1</code>, tức xem một điểm có thuộc class 1 hay không, hoặc xác suất để một điểm rơi vào class 1 là bao nhiêu. Tương tự như thế, classifier thứ hai sẽ phân biệt <code class=\"language-plaintext highlighter-rouge\">class 2</code> vs <code class=\"language-plaintext highlighter-rouge\">not class 2</code>, … Kết quả cuối cùng có thể được xác định bằng cách xác định class mà một điểm rơi vào với xác suất cao nhất.</p><p>Phương pháp này còn được gọi là <strong>one-hot coding</strong> (được sử dụng nhiều nên có rất nhiều tên) vì với cách mã hóa trên, giả sử có 4 classes, class 1, 2, 3, 4 sẽ lần lượt được mã hóa dưới dạng nhị phân bởi <code class=\"language-plaintext highlighter-rouge\">1000, 0100, 0010</code> hoặc <code class=\"language-plaintext highlighter-rouge\">0001</code>. One-hot vì chỉ có <em>one</em> bit là <em>hot</em> (bằng <code class=\"language-plaintext highlighter-rouge\">1</code>).</p><p>Hàm Logistic Regression trong thư viện sklearn có thể được dùng trực tiếp để áp dụng vào các bài toán multi-class classification với phương pháp <strong>one-vs-rest</strong>. Với bài toán MNIST như nêu ở phần 2, ta có thể thêm ba dòng lệnh sau để chạy trên toàn bộ 10 classes:</p><div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>logreg.fit(Xtrain_all, ytrain_all)\ny_pred = logreg.predict(Xtest_all)\nprint \"Accuracy: %.2f %%\" %(100*accuracy_score(ytest_all, y_pred.tolist()))\n</code></pre></div></div><p>Kết quả thu được khoảng 91% sau hơn 20 phút chạy (tùy thuộc vào máy). Đây vẫn là một kết quả quá thấp so với con số 99.7%. Thậm chí phương pháp học máy <em>không học gì</em> như <a href=\"/2017/01/08/knn/#try-this-yourself\">K-neareast neighbors cũng đã đạt hơn 96%</a> với thời gian chạy ngắn hơn một chút.</p><p>Một chú ý nhỏ: phương pháp mặc định cho các bài toán multi-class của hàm này được xác định bởi biến <code class=\"language-plaintext highlighter-rouge\">multi_class</code>. Có hai lựa chọn cho biến này, trong đó lựa chọn mặc định là <code class=\"language-plaintext highlighter-rouge\">ovr</code> tức <strong>one-vs-rest</strong>, lựa chọn còn lại sẽ được tôi đề cập trong một bài gần đây. Lựa chọn thứ hai không phải cho binary classifiers nên tôi không đề cập trong bài này, có thể sau một vài bài nữa (Xem thêm <a href=\"http://scikit-learn.org/stable/modules/generated/sklearn.linear_model.LogisticRegression.html\"><code class=\"language-plaintext highlighter-rouge\">sklearn.linear_model.LogisticRegression</code></a>)</p><p><a name=\"-thao-luan\"></a></p>"}}