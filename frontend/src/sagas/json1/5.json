{"topic": "<ul class=\"tags\">\n<a class=\"tag\" href=\"/tags#Neural-nets\">Neural-nets</a>\n<a class=\"tag\" href=\"/tags#Supervised-learning\">Supervised-learning</a>\n<a class=\"tag\" href=\"/tags#Regression\">Regression</a>\n<a class=\"tag\" href=\"/tags#Classification\">Classification</a>\n<a class=\"tag\" href=\"/tags#GD\">GD</a>\n</ul>", "title": "<h1 class=\"post-title\" itemprop=\"name\">Bài 10: Logistic Regression</h1>", "introduction": {"title": "<h2 id=\"1-giới-thiệu\">1. Giới thiệu</h2>", "content": "<p><a name=\"nhac-lai-hai-mo-hinh-tuyen-tinh\"></a></p><h3 id=\"nhắc-lại-hai-mô-hình-tuyến-tính\">Nhắc lại hai mô hình tuyến tính</h3><p>Hai mô hình tuyến tính (linear models) <a href=\"/2016/12/28/linearregression/\">Linear Regression</a> và <a href=\"/2017/01/21/perceptron/\">Perceptron Learning Algorithm</a> (PLA) chúng ta đã biết đều có chung một dạng:\n\\[\ny = f(\\mathbf{w}^T\\mathbf{x})\n\\]</p><p>trong đó \\(f()\\) được gọi là <em>activation function</em>, và \\(\\mathbf{x}\\) được hiểu là dữ liệu mở rộng với \\(x_0 = 1\\) được thêm vào để thuận tiện cho việc tính toán. Với linear regression thì \\(f(s) = s\\), với PLA thì \\(f(s) = \\text{sgn}(s)\\). Trong linear regression, tích vô hướng \\(\\mathbf{w}^T\\mathbf{x}\\) được trực tiếp sử dụng để dự đoán output \\(y\\), loại này phù hợp nếu chúng ta cần dự đoán một giá trị thực của đầu ra không bị chặn trên và dưới. Trong PLA, đầu ra chỉ nhận một trong hai giá trị \\(1\\) hoặc \\(-1 \\), phù hợp với các bài toán <em>binary classification</em>.</p><p>Trong bài này, tôi sẽ giới thiệu mô hình thứ ba với một activation khác, được sử dụng cho các bài toán <em>flexible</em> hơn. Trong dạng này, đầu ra có thể được thể hiện dưới dạng xác suất (probability). Ví dụ: xác suất thi đỗ nếu biết thời gian ôn thi, xác suất ngày mai có mưa dựa trên những thông tin đo được trong ngày hôm nay,… Mô hình mới này của chúng ta có tên là <em>logistic regression</em>. Mô hình này giống với linear regression ở khía cạnh đầu ra là số thực, và giống với PLA ở việc đầu ra bị chặn (trong đoạn \\([0, 1]\\)). Mặc dù trong tên có chứa từ <em>regression</em>, logistic regression thường được sử dụng nhiều hơn cho các bài toán classification.</p><p><a name=\"mot-vi-du-nho\"></a></p><h3 id=\"một-ví-dụ-nhỏ\">Một ví dụ nhỏ</h3><p>Tôi xin được sử dụng <a href=\"https://en.wikipedia.org/wiki/Logistic_regression\">một ví dụ trên Wikipedia</a>:</p><blockquote>\n<p>Một nhóm 20 sinh viên dành thời gian trong khoảng từ 0 đến 6 giờ cho việc ôn thi. Thời gian ôn thi này ảnh hưởng đến xác suất sinh viên vượt qua kỳ thi như thế nào?</p>\n</blockquote><p>Kết quả thu được như sau:</p><table>\n<thead>\n<tr>\n<th style=\"text-align: center\">Hours</th>\n<th style=\"text-align: center\">Pass</th>\n<th style=\"text-align: center\">Hours</th>\n<th style=\"text-align: center\">Pass</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align: center\">.5</td>\n<td style=\"text-align: center\">0</td>\n<td style=\"text-align: center\">2.75</td>\n<td style=\"text-align: center\">1</td>\n</tr>\n<tr>\n<td style=\"text-align: center\">.75</td>\n<td style=\"text-align: center\">0</td>\n<td style=\"text-align: center\">3</td>\n<td style=\"text-align: center\">0</td>\n</tr>\n<tr>\n<td style=\"text-align: center\">1</td>\n<td style=\"text-align: center\">0</td>\n<td style=\"text-align: center\">3.25</td>\n<td style=\"text-align: center\">1</td>\n</tr>\n<tr>\n<td style=\"text-align: center\">1.25</td>\n<td style=\"text-align: center\">0</td>\n<td style=\"text-align: center\">3.5</td>\n<td style=\"text-align: center\">0</td>\n</tr>\n<tr>\n<td style=\"text-align: center\">1.5</td>\n<td style=\"text-align: center\">0</td>\n<td style=\"text-align: center\">4</td>\n<td style=\"text-align: center\">1</td>\n</tr>\n<tr>\n<td style=\"text-align: center\">1.75</td>\n<td style=\"text-align: center\">0</td>\n<td style=\"text-align: center\">4.25</td>\n<td style=\"text-align: center\">1</td>\n</tr>\n<tr>\n<td style=\"text-align: center\">1.75</td>\n<td style=\"text-align: center\">1</td>\n<td style=\"text-align: center\">4.5</td>\n<td style=\"text-align: center\">1</td>\n</tr>\n<tr>\n<td style=\"text-align: center\">2</td>\n<td style=\"text-align: center\">0</td>\n<td style=\"text-align: center\">4.75</td>\n<td style=\"text-align: center\">1</td>\n</tr>\n<tr>\n<td style=\"text-align: center\">2.25</td>\n<td style=\"text-align: center\">1</td>\n<td style=\"text-align: center\">5</td>\n<td style=\"text-align: center\">1</td>\n</tr>\n<tr>\n<td style=\"text-align: center\">2.5</td>\n<td style=\"text-align: center\">0</td>\n<td style=\"text-align: center\">5.5</td>\n<td style=\"text-align: center\">1</td>\n</tr>\n</tbody>\n</table><p>Mặc dù có một chút <em>bất công</em> khi học 3.5 giờ thì trượt, còn học 1.75 giờ thì lại đỗ, nhìn chung, học càng nhiều thì khả năng đỗ càng cao. PLA không thể áp dụng được cho bài toán này vì không thể nói một người học bao nhiêu giờ thì 100% trượt hay đỗ, và thực tế là dữ liệu này cũng không <em>linearly separable</em> (điệu kiện để PLA có thể làm việc). Chú ý rằng các điểm màu đỏ và xanh được vẽ ở hai tung độ khác nhau để tiện cho việc minh họa. Các điểm này được vẽ dùng cả dữ liệu đầu vào \\(\\mathbf{x}\\) và đầu ra \\(y). Khi ta nói <em>linearly seperable</em> là khi ta chỉ dùng dữ liệu đầu vào \\(\\mathbf{x}\\).</p><p>Chúng ta biểu diễn các điểm này trên đồ thị để thấy rõ hơn:</p><div class=\"imgcap\">\n<img align=\"center\" src=\"\\assets\\LogisticRegression\\ex1.png\" width=\"800\"/>\n<div class=\"thecap\">Hình 1: Ví dụ về kết quả thi dựa trên số giờ ôn tập.</div>\n</div><p>Nhận thấy rằng cả linear regression và PLA đều không phù hợp với bài toán này, chúng ta cần một mô hình <em>flexible</em> hơn.</p><p><a name=\"mo-hinh-logistic-regression\"></a></p><h3 id=\"mô-hình-logistic-regression\">Mô hình Logistic Regression</h3><p>Đầu ra dự đoán của:</p><ul>\n<li>Linear Regression: \n\\[\nf(\\mathbf{x}) = \\mathbf{w}^T \\mathbf{x}\n\\]</li>\n<li>PLA:\n\\[\nf(\\mathbf{x}) = \\text{sgn}(\\mathbf{w}^T\\mathbf{x})\n\\]</li>\n</ul><p>Đầu ra dự đoán của logistic regression thường được viết chung dưới dạng:\n\\[\nf(\\mathbf{x}) = \\theta(\\mathbf{w}^T\\mathbf{x})\n\\]</p><p>Trong đó \\(\\theta\\) được gọi là logistic function. Một số activation cho mô hình tuyến tính được cho trong hình dưới đây:</p><div class=\"imgcap\">\n<img align=\"center\" src=\"\\assets\\LogisticRegression\\activation.png\" width=\"800\"/>\n<div class=\"thecap\">Hình 2: Các activation function khác nhau.</div>\n</div><ul>\n<li>Đường màu vàng biểu diễn linear regression. Đường này không bị chặn nên không phù hợp cho bài toán này. Có một <em>trick</em> nhỏ để đưa nó về dạng bị chặn: <em>cắt</em> phần nhỏ hơn 0 bằng cách cho chúng bằng 0, <em>cắt</em> các phần lớn hơn 1 bằng cách cho chúng bằng 1. Sau đó lấy điểm trên đường thẳng này có tung độ bằng 0.5 làm điểm phân chia hai <em>class</em>, đây cũng không phải là một lựa chọn tốt. Giả sử có thêm vài bạn <em>sinh viên tiêu biểu</em> ôn tập đến 20 giờ và, tất nhiên, thi đỗ. Khi áp dụng mô hình linear regression như hình dưới đây và lấy mốc 0.5 để phân lớp, toàn bộ sinh viên thi trượt vẫn được dự đoán là trượt, nhưng rất nhiều sinh viên thi đỗ cũng được dự đoán là trượt (nếu ta coi điểm x màu xanh lục là <em>ngưỡng cứng</em> để đưa ra kết luận). Rõ ràng đây là một mô hình không tốt. Anh chàng sinh viên tiêu biểu này đã <em>kéo theo</em> rất nhiều bạn khác bị trượt.</li>\n</ul><div class=\"imgcap\">\n<img align=\"center\" src=\"\\assets\\LogisticRegression\\ex1_lr.png\" width=\"800\"/>\n<div class=\"thecap\">Hình 3: Tại sao Linear Regression không phù hợp?</div>\n</div><ul>\n<li>Đường màu đỏ (chỉ khác với activation function của PLA ở chỗ  hai class là 0 và 1 thay vì -1 và 1) cũng thuộc dạng <em>ngưỡng cứng</em> (hard threshold). PLA không hoạt động trong bài toán này vì dữ liệu đã cho không <em>linearly separable</em>.</li>\n<li>\n<p>Các đường màu xanh lam và xanh lục phù hợp với bài toán của chúng ta hơn. Chúng có một vài tính chất quan trọng sau:</p>\n<ul>\n<li>Là hàm số liên tục nhận giá trị thực, bị chặn trong khoảng \\((0, 1)\\).</li>\n<li>Nếu coi điểm có tung độ là 1/2 làm điểm phân chia thì các điểm càng xa điểm này về phía bên trái có giá trị càng gần 0. Ngược lại, các điểm càng xa điểm này về phía phải có giá trị càng gần 1. Điều này <em>khớp</em> với nhận xét rằng học càng nhiều thì xác suất đỗ càng cao và ngược lại.</li>\n<li><em>Mượt</em> (smooth) nên có đạo hàm mọi nơi, có thể được lợi trong việc tối ưu.</li>\n</ul>\n</li>\n</ul><p><a name=\"sigmoid-function\"></a></p><h3 id=\"sigmoid-function\">Sigmoid function</h3><p>Trong số các hàm số có 3 tính chất nói trên thì hàm <em>sigmoid</em>:\n\\[\nf(s) = \\frac{1}{1 + e^{-s}} \\triangleq \\sigma(s)\n\\]\nđược sử dụng nhiều nhất, vì nó bị chặn trong khoảng \\((0, 1)\\). Thêm nữa:\n\\[\n\\lim_{s \\rightarrow -\\infty}\\sigma(s) = 0; ~~ \\lim_{s \\rightarrow +\\infty}\\sigma(s) = 1 \n\\]\nĐặc biệt hơn nữa:\n\\[\n\\begin{eqnarray}\n\\sigma’(s) &amp;=&amp; \\frac{e^{-s}}{(1 + e^{-s})^2} \\newline\n&amp;=&amp; \\frac{1}{1 + e^{-s}} \\frac{e^{-s}}{1 + e^{-s}} \\newline\n&amp;=&amp; \\sigma(s)(1 - \\sigma(s))\n\\end{eqnarray}\n\\]\nCông thức đạo hàm đơn giản thế này giúp hàm số này được sử dụng rộng rãi. Ở phần sau, tôi sẽ lý giải việc <em>người ta đã tìm ra hàm số đặc biệt này như thế nào</em>.</p><p><a name=\"tanh-function\"></a></p><p>Ngoài ra, hàm <em>tanh</em> cũng hay được sử dụng: \n\\[\n\\text{tanh}(s) = \\frac{e^{s} - e^{-s}}{e^s + e^{-s}}\n\\]</p><p>Hàm số này nhận giá trị trong khoảng \\((-1, 1)\\) nhưng có thể dễ dàng đưa nó về khoảng \\((0, 1)\\). Bạn đọc có thể chứng minh được:\n\\[\n\\text{tanh}(s) = 2\\sigma(2s) - 1\n\\]</p><p><a name=\"-ham-mat-mat-va-phuong-phap-toi-uu\"></a></p>"}, "formulas": {"title": "<h2 id=\"2-hàm-mất-mát-và-phương-pháp-tối-ưu\">2. Hàm mất mát và phương pháp tối ưu</h2>", "content": "<p><a name=\"xay-dung-ham-mat-mat\"></a></p><h3 id=\"xây-dựng-hàm-mất-mát\">Xây dựng hàm mất mát</h3><p>Với mô hình như trên (các activation màu xanh lam và lục), ta có thể giả sử rằng xác suất để một điểm dữ liệu \\(\\mathbf{x}\\) rơi vào class 1 là \\(f(\\mathbf{w}^T\\mathbf{x})\\) và rơi vào class 0 là \\(1 - f(\\mathbf{w}^T\\mathbf{x})\\). Với mô hình được giả sử như vậy, với các điểm dữ liệu training (đã biết đầu ra \\(y\\)), ta có thể viết như sau:</p><p>\\[\n\\begin{eqnarray}\nP(y_i = 1 | \\mathbf{x}_i; \\mathbf{w}) &amp;=&amp; &amp;f(\\mathbf{w}^T\\mathbf{x}_i)  ~~(1) \\newline\nP(y_i = 0 | \\mathbf{x}_i; \\mathbf{w}) &amp;=&amp; 1 - &amp;f(\\mathbf{w}^T\\mathbf{x}_i)  ~~(2) \\newline\n\\end{eqnarray}\n\\]\ntrong đó \\( P(y_i = 1 | \\mathbf{x}_i; \\mathbf{w})\\) được hiểu là xác suất xảy ra sự kiện đầu ra \\(y_i = 1\\) khi biết tham số mô hình \\(\\mathbf{w}\\) và dữ liệu đầu vào \\(\\mathbf{x}_i\\). Bạn đọc có thể đọc thêm <a href=\"https://vi.wikipedia.org/wiki/Xác_suất_có_điều_kiện\">Xác suất có điều kiện</a>. Mục đích của chúng ta là tìm các hệ số \\(\\mathbf{w}\\) sao cho \\(f(\\mathbf{w}^T\\mathbf{x}_i)\\) càng gần với 1 càng tốt với các điểm dữ liệu thuộc class 1 và càng gần với 0 càng tốt với những điểm thuộc class 0.</p><p>Ký hiệu \\(z_i = f(\\mathbf{w}^T\\mathbf{x}_i)\\) và viết gộp lại hai biểu thức bên trên ta có:\n\\[\nP(y_i| \\mathbf{x}_i; \\mathbf{w}) = z_i^{y_i}(1 - z_i)^{1- y_i}\n\\]</p><p>Biểu thức này là tương đương với hai biểu thức \\((1)\\) và \\((2)\\) ở trên vì khi \\(y_i=1\\), phần thứ hai của vế phải sẽ triệt tiêu, khi \\(y_i = 0\\), phần thứ nhất sẽ bị triệt tiêu! Chúng ta muốn mô hình gần với dữ liệu đã cho nhất, tức xác suất này đạt giá trị cao nhất.</p><p>Xét toàn bộ training set với \\(\\mathbf{X} = [\\mathbf{x}_1,\\mathbf{x}_2, \\dots, \\mathbf{x}_N] \\in \\mathbb{R}^{d \\times N}\\) và \\(\\mathbf{y} = [y_1, y_2, \\dots, y_N]\\), chúng ta cần tìm \\(\\mathbf{w}\\) để biểu thức sau đây đạt giá trị lớn nhất:\n\\[\nP(\\mathbf{y}|\\mathbf{X}; \\mathbf{w})\n\\]\nở đây, ta cũng ký hiệu \\(\\mathbf{X, y}\\) như các <a href=\"https://vi.wikipedia.org/wiki/Biến_ngẫu_nhiên\">biến ngẫu nhiên</a> (random variables). Nói cách khác:\n\\[\n\\mathbf{w} = \\arg\\max_{\\mathbf{w}} P(\\mathbf{y}|\\mathbf{X}; \\mathbf{w})\n\\]</p><p><a name=\"maximun likelihood estimation\"></a></p><p>Bài toán tìm tham số để mô hình gần với dữ liệu nhất trên đây có tên gọi chung là bài toán <a href=\"https://en.wikipedia.org/wiki/Maximum_likelihood_estimation\"><em>maximum likelihood estimation</em></a> với hàm số phía sau \\(\\arg\\max\\) được gọi là <em>likelihood function</em>. Khi làm việc với các bài toán Machine Learning sử dụng các mô hình xác suất thống kê, chúng ta sẽ gặp lại các bài toán thuộc dạng này, hoặc <a href=\"https://en.wikipedia.org/wiki/Maximum_a_posteriori_estimation\"><em>maximum a posteriori estimation</em></a>, rất nhiều. Tôi sẽ dành 1 bài khác để nói về hai dạng bài toán này.</p><p>Giả sử thêm rằng các điểm dữ liệu được sinh ra một cách ngẫu nhiên độc lập với nhau (independent), ta có thể viết:\n\\[\n\\begin{eqnarray}\nP(\\mathbf{y}|\\mathbf{X}; \\mathbf{w}) &amp;=&amp; \\prod_{i=1}^N P(y_i| \\mathbf{x}_i; \\mathbf{w}) \\newline\n&amp;=&amp; \\prod_{i=1}^N z_i^{y_i}(1 - z_i)^{1- y_i}\n\\end{eqnarray}\n\\]\nvới \\(\\prod\\) là ký hiệu của tích. Bạn đọc có thể muốn đọc thêm về <a href=\"https://vi.wikipedia.org/wiki/Độc_lập_thống_kê\">Độc lập thống kê</a>.</p><p>Trực tiếp tối ưu hàm số này theo \\(\\mathbf{w}\\) nhìn qua không đơn giản! Hơn nữa, khi \\(N\\) lớn, tích của \\(N\\) số nhỏ hơn 1 có thể dẫn tới sai số trong tính toán (numerial error) vì tích là một số quá nhỏ. Một phương pháp thường được sử dụng đó là lấy logarit tự nhiên (cơ số \\(e\\)) của  <em>likelihood function</em> biến phép nhân thành phép cộng và để tránh việc số quá nhỏ. Sau đó lấy ngược dấu để được một hàm và coi nó là hàm mất mát. Lúc này bài toán tìm giá trị lớn nhất (maximum likelihood) trở thành bài toán tìm giá trị nhỏ nhất của hàm mất mát (hàm này còn được gọi là negative log likelihood):\n\\[\n\\begin{eqnarray}\nJ(\\mathbf{w}) = -\\log P(\\mathbf{y}|\\mathbf{X}; \\mathbf{w}) \\newline\n= -\\sum_{i=1}^N(y_i \\log {z}_i + (1-y_i) \\log (1 - {z}_i))\n\\end{eqnarray}\n\\]\nvới chú ý rằng \\(z_i\\) là một hàm số của \\(\\mathbf{w}\\). Bạn đọc tạm nhớ biểu thức vế phải có tên gọi là <em>cross entropy</em>, thường được sử dụng để đo <em>khoảng cách</em> giữa hai phân phối (distributions). Trong bài toán đang xét, một phân phối là dữ liệu được cho, với xác suất chỉ là 0 hoặc 1; phân phối còn lại được tính theo mô hình logistic regression. <em>Khoảng cách</em> giữa hai phân phối nhỏ đồng nghĩa với việc (<em>có vẻ hiển nhiên là</em>) hai phân phối đó rất gần nhau. Tính chất cụ thể của hàm số này sẽ được đề cập trong một bài khác mà tầm quan trọng của khoảng cách giữa hai phân phối là lớn hơn.</p><p><strong>Chú ý:</strong> Trong machine learning, logarit thập phân ít được dùng, vì vậy \\(\\log\\) thường được dùng để ký hiệu logarit tự nhiên.</p><p><a name=\"toi-uu-ham-mat-mat\"></a></p><h3 id=\"tối-ưu-hàm-mất-mát\">Tối ưu hàm mất mát</h3><p>Chúng ta lại sử dụng phương pháp <a href=\"/2017/01/16/gradientdescent2/#-stochastic-gradient-descent\">Stochastic Gradient Descent</a> (SGD) ở đây (<em>Bạn đọc được khuyến khích đọc SGD trước khi đọc phần này</em>) . Hàm mất mát với chỉ một điểm dữ liệu \\((\\mathbf{x}_i, y_i)\\) là:\n\\[\nJ(\\mathbf{w}; \\mathbf{x}_i, y_i) = -(y_i \\log {z}_i + (1-y_i) \\log (1 - {z}_i))\n\\]</p><p>Với đạo hàm:\n\\[\n\\begin{eqnarray}\n\\frac{\\partial J(\\mathbf{w}; \\mathbf{x}_i, y_i)}{\\partial \\mathbf{w}} &amp;=&amp; -(\\frac{y_i}{z_i} - \\frac{1- y_i}{1 - z_i} ) \\frac{\\partial z_i}{\\partial \\mathbf{w}} \\newline\n&amp;=&amp; \\frac{z_i - y_i}{z_i(1 - z_i)} \\frac{\\partial z_i}{\\partial \\mathbf{w}} ~~~~~~ (3)\n\\end{eqnarray}\n\\]</p><p>Để cho biểu thức này trở nên <em>gọn</em> và <em>đẹp</em> hơn, chúng ta sẽ tìm hàm \\(z = f(\\mathbf{w}^T\\mathbf{x})\\) sao cho mẫu số bị triệt tiêu. Nếu đặt \\(s = \\mathbf{w}^T\\mathbf{x}\\), chúng ta sẽ có:\n\\[\n\\frac{\\partial z_i}{\\partial \\mathbf{w}} = \\frac{\\partial z_i}{\\partial s} \\frac{\\partial s}{\\partial \\mathbf{w}} = \\frac{\\partial z_i}{\\partial s} \\mathbf{x}\n\\]\nMột cách trực quan nhất, ta sẽ tìm hàm số \\(z = f(s)\\) sao cho:\n\\[\n\\frac{\\partial z}{\\partial s} = z(1 - z) ~~ (4)\n\\]\nđể triệt tiêu mẫu số trong biểu thức \\((3)\\). Chúng ta cùng khởi động một chút với phương trình vi phân đơn giản này. Phương trình \\((4)\\) tương đương với:\n\\[\n\\begin{eqnarray}\n&amp;\\frac{\\partial z}{z(1-z)} &amp;=&amp; \\partial s \\newline\n\\Leftrightarrow &amp; (\\frac{1}{z} + \\frac{1}{1 - z})\\partial z &amp;=&amp;\\partial s \\newline\n\\Leftrightarrow &amp; \\log z - \\log(1 - z) &amp;=&amp; s \\newline\n\\Leftrightarrow &amp; \\log \\frac{z}{1 - z} &amp;=&amp; s \\newline\n\\Leftrightarrow &amp; \\frac{z}{1 - z} &amp;=&amp; e^s \\newline\n\\Leftrightarrow &amp; z &amp;=&amp; e^s (1 - z) \\newline\n\\Leftrightarrow &amp; z = \\frac{e^s}{1 +e^s} &amp;=&amp;\\frac{1}{1 + e^{-s}} = \\sigma(s)\n\\end{eqnarray}\n\\]\nĐến đây, tôi hy vọng các bạn đã hiểu hàm số <em>sigmoid</em> được tạo ra như thế nào.</p><p><em>Chú ý: Trong việc giải phương trình vi phân ở trên, tôi đã bỏ qua hằng số khi lấy nguyên hàm hai vế. Tuy vậy, việc này không ảnh hưởng nhiều tới kết quả.</em></p><p><a name=\"cong-thuc-cap-nhat-cho-logistic-sigmoid-regression\"></a></p><h3 id=\"công-thức-cập-nhật-cho-logistic-sigmoid-regression\">Công thức cập nhật cho logistic sigmoid regression</h3><p>Tới đây, bạn đọc có thể kiểm tra rằng:\n\\[\n\\frac{\\partial J(\\mathbf{w}; \\mathbf{x}_i, y_i)}{\\partial \\mathbf{w}} = (z_i - y_i)\\mathbf{x}_i\n\\]\nQúa đẹp!</p><p>Và công thức cập nhật (theo thuật toán <a href=\"/2017/01/16/gradientdescent2/#-stochastic-gradient-descent\">SGD</a>) cho logistic regression là: \n\\[\n\\mathbf{w} = \\mathbf{w} + \\eta(y_i - z_i)\\mathbf{x}_i\n\\]\nKhá đơn giản! Và, như thường lệ, chúng ta sẽ có vài ví dụ với Python.</p><p><a name=\"-vi-du-voi-python\"></a></p>"}, "examples": {"title": "<h2 id=\"3-ví-dụ-với-python\">3. Ví dụ với Python</h2>", "content": "<p><a name=\"vi-du-voi-du-lieu--chieu\"></a></p><h3 id=\"ví-dụ-với-dữ-liệu-1-chiều\">Ví dụ với dữ liệu 1 chiều</h3><p>Quay trở lại với ví dụ nêu ở phần Giới thiệu. Trước tiên ta cần khai báo vài thư viện và dữ liệu:</p><div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\"># To support both python 2 and python 3\n</span><span class=\"kn\">from</span> <span class=\"nn\">__future__</span> <span class=\"kn\">import</span> <span class=\"n\">division</span><span class=\"p\">,</span> <span class=\"n\">print_function</span><span class=\"p\">,</span> <span class=\"n\">unicode_literals</span>\n<span class=\"kn\">import</span> <span class=\"nn\">numpy</span> <span class=\"k\">as</span> <span class=\"n\">np</span> \n<span class=\"kn\">import</span> <span class=\"nn\">matplotlib.pyplot</span> <span class=\"k\">as</span> <span class=\"n\">plt</span>\n<span class=\"n\">np</span><span class=\"p\">.</span><span class=\"n\">random</span><span class=\"p\">.</span><span class=\"n\">seed</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">)</span>\n\n<span class=\"n\">X</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"p\">.</span><span class=\"n\">array</span><span class=\"p\">([[</span><span class=\"mf\">0.50</span><span class=\"p\">,</span> <span class=\"mf\">0.75</span><span class=\"p\">,</span> <span class=\"mf\">1.00</span><span class=\"p\">,</span> <span class=\"mf\">1.25</span><span class=\"p\">,</span> <span class=\"mf\">1.50</span><span class=\"p\">,</span> <span class=\"mf\">1.75</span><span class=\"p\">,</span> <span class=\"mf\">1.75</span><span class=\"p\">,</span> <span class=\"mf\">2.00</span><span class=\"p\">,</span> <span class=\"mf\">2.25</span><span class=\"p\">,</span> <span class=\"mf\">2.50</span><span class=\"p\">,</span> \n              <span class=\"mf\">2.75</span><span class=\"p\">,</span> <span class=\"mf\">3.00</span><span class=\"p\">,</span> <span class=\"mf\">3.25</span><span class=\"p\">,</span> <span class=\"mf\">3.50</span><span class=\"p\">,</span> <span class=\"mf\">4.00</span><span class=\"p\">,</span> <span class=\"mf\">4.25</span><span class=\"p\">,</span> <span class=\"mf\">4.50</span><span class=\"p\">,</span> <span class=\"mf\">4.75</span><span class=\"p\">,</span> <span class=\"mf\">5.00</span><span class=\"p\">,</span> <span class=\"mf\">5.50</span><span class=\"p\">]])</span>\n<span class=\"n\">y</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"p\">.</span><span class=\"n\">array</span><span class=\"p\">([</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">])</span>\n\n<span class=\"c1\"># extended data \n</span><span class=\"n\">X</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"p\">.</span><span class=\"n\">concatenate</span><span class=\"p\">((</span><span class=\"n\">np</span><span class=\"p\">.</span><span class=\"n\">ones</span><span class=\"p\">((</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">X</span><span class=\"p\">.</span><span class=\"n\">shape</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">])),</span> <span class=\"n\">X</span><span class=\"p\">),</span> <span class=\"n\">axis</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">)</span>\n</code></pre></div></div><p><a name=\"cac-ham-can-thiet-cho-logistic-sigmoid-regression\"></a></p><h3 id=\"các-hàm-cần-thiết-cho-logistic-sigmoid-regression\">Các hàm cần thiết cho logistic sigmoid regression</h3><div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">def</span> <span class=\"nf\">sigmoid</span><span class=\"p\">(</span><span class=\"n\">s</span><span class=\"p\">):</span>\n    <span class=\"k\">return</span> <span class=\"mi\">1</span><span class=\"o\">/</span><span class=\"p\">(</span><span class=\"mi\">1</span> <span class=\"o\">+</span> <span class=\"n\">np</span><span class=\"p\">.</span><span class=\"n\">exp</span><span class=\"p\">(</span><span class=\"o\">-</span><span class=\"n\">s</span><span class=\"p\">))</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">logistic_sigmoid_regression</span><span class=\"p\">(</span><span class=\"n\">X</span><span class=\"p\">,</span> <span class=\"n\">y</span><span class=\"p\">,</span> <span class=\"n\">w_init</span><span class=\"p\">,</span> <span class=\"n\">eta</span><span class=\"p\">,</span> <span class=\"n\">tol</span> <span class=\"o\">=</span> <span class=\"mf\">1e-4</span><span class=\"p\">,</span> <span class=\"n\">max_count</span> <span class=\"o\">=</span> <span class=\"mi\">10000</span><span class=\"p\">):</span>\n    <span class=\"n\">w</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">w_init</span><span class=\"p\">]</span>    \n    <span class=\"n\">it</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>\n    <span class=\"n\">N</span> <span class=\"o\">=</span> <span class=\"n\">X</span><span class=\"p\">.</span><span class=\"n\">shape</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span>\n    <span class=\"n\">d</span> <span class=\"o\">=</span> <span class=\"n\">X</span><span class=\"p\">.</span><span class=\"n\">shape</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span>\n    <span class=\"n\">count</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>\n    <span class=\"n\">check_w_after</span> <span class=\"o\">=</span> <span class=\"mi\">20</span>\n    <span class=\"k\">while</span> <span class=\"n\">count</span> <span class=\"o\">&lt;</span> <span class=\"n\">max_count</span><span class=\"p\">:</span>\n        <span class=\"c1\"># mix data \n</span>        <span class=\"n\">mix_id</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"p\">.</span><span class=\"n\">random</span><span class=\"p\">.</span><span class=\"n\">permutation</span><span class=\"p\">(</span><span class=\"n\">N</span><span class=\"p\">)</span>\n        <span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"n\">mix_id</span><span class=\"p\">:</span>\n            <span class=\"n\">xi</span> <span class=\"o\">=</span> <span class=\"n\">X</span><span class=\"p\">[:,</span> <span class=\"n\">i</span><span class=\"p\">].</span><span class=\"n\">reshape</span><span class=\"p\">(</span><span class=\"n\">d</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">)</span>\n            <span class=\"n\">yi</span> <span class=\"o\">=</span> <span class=\"n\">y</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span>\n            <span class=\"n\">zi</span> <span class=\"o\">=</span> <span class=\"n\">sigmoid</span><span class=\"p\">(</span><span class=\"n\">np</span><span class=\"p\">.</span><span class=\"n\">dot</span><span class=\"p\">(</span><span class=\"n\">w</span><span class=\"p\">[</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">].</span><span class=\"n\">T</span><span class=\"p\">,</span> <span class=\"n\">xi</span><span class=\"p\">))</span>\n            <span class=\"n\">w_new</span> <span class=\"o\">=</span> <span class=\"n\">w</span><span class=\"p\">[</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">+</span> <span class=\"n\">eta</span><span class=\"o\">*</span><span class=\"p\">(</span><span class=\"n\">yi</span> <span class=\"o\">-</span> <span class=\"n\">zi</span><span class=\"p\">)</span><span class=\"o\">*</span><span class=\"n\">xi</span>\n            <span class=\"n\">count</span> <span class=\"o\">+=</span> <span class=\"mi\">1</span>\n            <span class=\"c1\"># stopping criteria\n</span>            <span class=\"k\">if</span> <span class=\"n\">count</span><span class=\"o\">%</span><span class=\"n\">check_w_after</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"p\">:</span>                \n                <span class=\"k\">if</span> <span class=\"n\">np</span><span class=\"p\">.</span><span class=\"n\">linalg</span><span class=\"p\">.</span><span class=\"n\">norm</span><span class=\"p\">(</span><span class=\"n\">w_new</span> <span class=\"o\">-</span> <span class=\"n\">w</span><span class=\"p\">[</span><span class=\"o\">-</span><span class=\"n\">check_w_after</span><span class=\"p\">])</span> <span class=\"o\">&lt;</span> <span class=\"n\">tol</span><span class=\"p\">:</span>\n                    <span class=\"k\">return</span> <span class=\"n\">w</span>\n            <span class=\"n\">w</span><span class=\"p\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"n\">w_new</span><span class=\"p\">)</span>\n    <span class=\"k\">return</span> <span class=\"n\">w</span>\n<span class=\"n\">eta</span> <span class=\"o\">=</span> <span class=\"p\">.</span><span class=\"mi\">05</span> \n<span class=\"n\">d</span> <span class=\"o\">=</span> <span class=\"n\">X</span><span class=\"p\">.</span><span class=\"n\">shape</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span>\n<span class=\"n\">w_init</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"p\">.</span><span class=\"n\">random</span><span class=\"p\">.</span><span class=\"n\">randn</span><span class=\"p\">(</span><span class=\"n\">d</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">)</span>\n\n<span class=\"n\">w</span> <span class=\"o\">=</span> <span class=\"n\">logistic_sigmoid_regression</span><span class=\"p\">(</span><span class=\"n\">X</span><span class=\"p\">,</span> <span class=\"n\">y</span><span class=\"p\">,</span> <span class=\"n\">w_init</span><span class=\"p\">,</span> <span class=\"n\">eta</span><span class=\"p\">)</span>\n<span class=\"k\">print</span><span class=\"p\">(</span><span class=\"n\">w</span><span class=\"p\">[</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">])</span>\n</code></pre></div></div><div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>[[-4.092695  ]\n [ 1.55277242]]\n</code></pre></div></div><p>Với kết quả tìm được, đầu ra \\(y\\) có thể được dự đoán theo công thức: <code class=\"language-plaintext highlighter-rouge\">y = sigmoid(-4.1 + 1.55*x)</code>. Với dữ liệu trong tập training, kết quả là:</p><div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">print</span><span class=\"p\">(</span><span class=\"n\">sigmoid</span><span class=\"p\">(</span><span class=\"n\">np</span><span class=\"p\">.</span><span class=\"n\">dot</span><span class=\"p\">(</span><span class=\"n\">w</span><span class=\"p\">[</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">].</span><span class=\"n\">T</span><span class=\"p\">,</span> <span class=\"n\">X</span><span class=\"p\">)))</span>\n</code></pre></div></div><div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>[[ 0.03281144  0.04694533  0.06674738  0.09407764  0.13102736  0.17961209\n   0.17961209  0.24121129  0.31580406  0.40126557  0.49318368  0.58556493\n   0.67229611  0.74866712  0.86263755  0.90117058  0.92977426  0.95055357\n   0.96541314  0.98329067]]\n</code></pre></div></div><p>Biểu diễn kết quả này trên đồ thị ta có:</p><div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"n\">X0</span> <span class=\"o\">=</span> <span class=\"n\">X</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">np</span><span class=\"p\">.</span><span class=\"n\">where</span><span class=\"p\">(</span><span class=\"n\">y</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"p\">)][</span><span class=\"mi\">0</span><span class=\"p\">]</span>\n<span class=\"n\">y0</span> <span class=\"o\">=</span> <span class=\"n\">y</span><span class=\"p\">[</span><span class=\"n\">np</span><span class=\"p\">.</span><span class=\"n\">where</span><span class=\"p\">(</span><span class=\"n\">y</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"p\">)]</span>\n<span class=\"n\">X1</span> <span class=\"o\">=</span> <span class=\"n\">X</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">np</span><span class=\"p\">.</span><span class=\"n\">where</span><span class=\"p\">(</span><span class=\"n\">y</span> <span class=\"o\">==</span> <span class=\"mi\">1</span><span class=\"p\">)][</span><span class=\"mi\">0</span><span class=\"p\">]</span>\n<span class=\"n\">y1</span> <span class=\"o\">=</span> <span class=\"n\">y</span><span class=\"p\">[</span><span class=\"n\">np</span><span class=\"p\">.</span><span class=\"n\">where</span><span class=\"p\">(</span><span class=\"n\">y</span> <span class=\"o\">==</span> <span class=\"mi\">1</span><span class=\"p\">)]</span>\n\n<span class=\"n\">plt</span><span class=\"p\">.</span><span class=\"n\">plot</span><span class=\"p\">(</span><span class=\"n\">X0</span><span class=\"p\">,</span> <span class=\"n\">y0</span><span class=\"p\">,</span> <span class=\"s\">'ro'</span><span class=\"p\">,</span> <span class=\"n\">markersize</span> <span class=\"o\">=</span> <span class=\"mi\">8</span><span class=\"p\">)</span>\n<span class=\"n\">plt</span><span class=\"p\">.</span><span class=\"n\">plot</span><span class=\"p\">(</span><span class=\"n\">X1</span><span class=\"p\">,</span> <span class=\"n\">y1</span><span class=\"p\">,</span> <span class=\"s\">'bs'</span><span class=\"p\">,</span> <span class=\"n\">markersize</span> <span class=\"o\">=</span> <span class=\"mi\">8</span><span class=\"p\">)</span>\n\n<span class=\"n\">xx</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"p\">.</span><span class=\"n\">linspace</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">6</span><span class=\"p\">,</span> <span class=\"mi\">1000</span><span class=\"p\">)</span>\n<span class=\"n\">w0</span> <span class=\"o\">=</span> <span class=\"n\">w</span><span class=\"p\">[</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">][</span><span class=\"mi\">0</span><span class=\"p\">][</span><span class=\"mi\">0</span><span class=\"p\">]</span>\n<span class=\"n\">w1</span> <span class=\"o\">=</span> <span class=\"n\">w</span><span class=\"p\">[</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">][</span><span class=\"mi\">1</span><span class=\"p\">][</span><span class=\"mi\">0</span><span class=\"p\">]</span>\n<span class=\"n\">threshold</span> <span class=\"o\">=</span> <span class=\"o\">-</span><span class=\"n\">w0</span><span class=\"o\">/</span><span class=\"n\">w1</span>\n<span class=\"n\">yy</span> <span class=\"o\">=</span> <span class=\"n\">sigmoid</span><span class=\"p\">(</span><span class=\"n\">w0</span> <span class=\"o\">+</span> <span class=\"n\">w1</span><span class=\"o\">*</span><span class=\"n\">xx</span><span class=\"p\">)</span>\n<span class=\"n\">plt</span><span class=\"p\">.</span><span class=\"n\">axis</span><span class=\"p\">([</span><span class=\"o\">-</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">8</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">])</span>\n<span class=\"n\">plt</span><span class=\"p\">.</span><span class=\"n\">plot</span><span class=\"p\">(</span><span class=\"n\">xx</span><span class=\"p\">,</span> <span class=\"n\">yy</span><span class=\"p\">,</span> <span class=\"s\">'g-'</span><span class=\"p\">,</span> <span class=\"n\">linewidth</span> <span class=\"o\">=</span> <span class=\"mi\">2</span><span class=\"p\">)</span>\n<span class=\"n\">plt</span><span class=\"p\">.</span><span class=\"n\">plot</span><span class=\"p\">(</span><span class=\"n\">threshold</span><span class=\"p\">,</span> <span class=\"p\">.</span><span class=\"mi\">5</span><span class=\"p\">,</span> <span class=\"s\">'y^'</span><span class=\"p\">,</span> <span class=\"n\">markersize</span> <span class=\"o\">=</span> <span class=\"mi\">8</span><span class=\"p\">)</span>\n<span class=\"n\">plt</span><span class=\"p\">.</span><span class=\"n\">xlabel</span><span class=\"p\">(</span><span class=\"s\">'studying hours'</span><span class=\"p\">)</span>\n<span class=\"n\">plt</span><span class=\"p\">.</span><span class=\"n\">ylabel</span><span class=\"p\">(</span><span class=\"s\">'predicted probability of pass'</span><span class=\"p\">)</span>\n<span class=\"n\">plt</span><span class=\"p\">.</span><span class=\"n\">show</span><span class=\"p\">()</span>\n</code></pre></div></div><div class=\"imgcap\">\n<img align=\"center\" src=\"\\assets\\LogisticRegression\\lg_results.png\" width=\"600\"/>\n<div class=\"thecap\">Hình 4: Dữ liệu và hàm sigmoid tìm được.</div>\n</div><p>Nếu như chỉ có hai output là ‘fail’ hoặc ‘pass’, điểm trên đồ thị của hàm sigmoid tương ứng với xác suất 0.5 được chọn làm <em>hard threshold</em> (ngưỡng cứng). Việc này có thể chứng minh khá dễ dàng (tôi sẽ bàn ở phần dưới).</p><p><a name=\"vi-du-voi-du-lieu--chieu-1\"></a></p><h3 id=\"ví-dụ-với-dữ-liệu-2-chiều\">Ví dụ với dữ liệu 2 chiều</h3><p>Chúng ta xét thêm một ví dụ nhỏ nữa trong không gian hai chiều. Giả sử chúng ta có hai class xanh-đỏ với dữ liệu được phân bố như hình dưới.</p><div class=\"imgcap\">\n<img align=\"center\" src=\"\\assets\\LogisticRegression\\logistic_2d.png\" width=\"400\"/>\n<div class=\"thecap\">Hình 5: Hai class với dữ liệu hai chiều.</div>\n</div><p>Với dữ liệu đầu vào nằm trong không gian hai chiều, hàm sigmoid có dạng như thác nước dưới đây:</p><div class=\"imgcap\">\n<img align=\"center\" src=\"http://galaxy.agh.edu.pl/~vlsi/AI/bias/img/plaszczyzna.gif\" width=\"400\"/>\n<div class=\"thecap\">Hình 6: Hàm sigmoid với dữ liệu có chiều là 2. (Nguồn: <a href=\"http://galaxy.agh.edu.pl/~vlsi/AI/bias/bias_eng.html\">Biased and non biased neurons</a>)</div>\n</div><p>Kết quả tìm được khi áp dụng mô hình logistic regression được minh họa như hình dưới với màu nền khác nhau thể hiện xác suất điểm đó thuộc class đỏ. Đỏ hơn tức gần 1 hơn, xanh hơn tức gần 0 hơn.</p><div class=\"imgcap\">\n<img align=\"center\" src=\"\\assets\\LogisticRegression\\logistic_2d_2.png\" width=\"400\"/>\n<div class=\"thecap\">Hình 7: Logistic Regression với dữ liệu hai chiều.</div>\n</div><p>Nếu phải lựa chọn một <em>ngưỡng cứng</em> (chứ không chấp nhận xác suất) để phân chia hai class, chúng ta quan sát thấy đường thẳng nằm nằm trong khu vực xanh lục là một lựa chọn hợp lý. Tôi sẽ chứng minh ở phần dưới rằng, đường phân chia giữa hai class tìm được bởi logistic regression có dạng một đường phẳng, tức vẫn là linear.</p><p><a name=\"-mot-vai-tinh-chat-cua-logistic-regression\"></a></p>"}}